{
  "qualifiedName": "@ScrapeGraphAI/scrapegraph-mcp",
  "displayName": "ScrapeGraph AI Integration Server",
  "description": "Enable language models to perform advanced AI-powered web scraping with enterprise-grade reliability. Transform webpages into structured markdown, extract data using AI, and execute AI-powered web searches seamlessly. Enhance your applications with powerful web data extraction capabilities through this integration.\n\nIt could also make web search, browser automation and markdownification",
  "iconUrl": "https://icons.duckduckgo.com/ip3/scrapegraphai.com.ico",
  "remote": true,
  "deploymentUrl": "https://server.smithery.ai/@ScrapeGraphAI/scrapegraph-mcp",
  "connections": [
    {
      "type": "http",
      "deploymentUrl": "https://server.smithery.ai/@ScrapeGraphAI/scrapegraph-mcp/mcp",
      "configSchema": {
        "type": "object",
        "title": "ConfigSchema",
        "properties": {
          "scrapegraphApiKey": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scrapegraphapikey",
            "default": null,
            "description": "Your Scrapegraph API key (optional - can also be set via SGAI_API_KEY environment variable)"
          }
        },
        "description": "Schema for the /mcp endpoint configuration",
        "x-query-style": "dot+bracket"
      }
    }
  ],
  "security": null,
  "tools": [
    {
      "name": "markdownify",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": true,
        "destructiveHint": false
      },
      "description": "Convert a webpage into clean, formatted markdown.\n\nThis tool fetches any webpage and converts its content into clean, readable markdown format.\nUseful for extracting content from documentation, articles, and web pages for further processing.\nCosts 2 credits per page. Read-only operation with no side effects.\n\nArgs:\n    website_url (str): The complete URL of the webpage to convert to markdown format.\n        - Must include protocol (http:// or https://)\n        - Supports most web content types (HTML, articles, documentation)\n        - Works with both static and dynamic content\n        - Examples:\n          * https://example.com/page\n          * https://docs.python.org/3/tutorial/\n          * https://github.com/user/repo/README.md\n        - Invalid examples:\n          * example.com (missing protocol)\n          * ftp://example.com (unsupported protocol)\n          * localhost:3000 (missing protocol)\n\nReturns:\n    Dictionary containing:\n    - markdown: The converted markdown content as a string\n    - metadata: Additional information about the conversion (title, description, etc.)\n    - status: Success/error status of the operation\n    - credits_used: Number of credits consumed (always 2 for this operation)\n\nRaises:\n    ValueError: If website_url is malformed or missing protocol\n    HTTPError: If the webpage cannot be accessed or returns an error\n    TimeoutError: If the webpage takes too long to load (>120 seconds)",
      "inputSchema": {
        "type": "object",
        "required": [
          "website_url"
        ],
        "properties": {
          "website_url": {
            "type": "string"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "smartscraper",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": true,
        "destructiveHint": false
      },
      "description": "    Extract structured data from a webpage, HTML, or markdown using AI-powered extraction.\n\n    This tool uses advanced AI to understand your natural language prompt and extract specific\n    structured data from web content. Supports three input modes: URL scraping. Ideal for extracting product information, contact details,\n    article metadata, or any structured content. Costs 10 credits per page. Read-only operation.\n\n    Args:\n        user_prompt (str): Natural language instructions describing what data to extract.\n            - Be specific about the fields you want for better results\n            - Use clear, descriptive language about the target data\n            - Examples:\n              * \"Extract product name, price, description, and availability status\"\n              * \"Find all contact methods: email addresses, phone numbers, and social media links\"\n              * \"Get article title, author, publication date, and summary\"\n              * \"Extract all job listings with title, company, location, and salary\"\n            - Tips for better results:\n              * Specify exact field names you want\n              * Mention data types (numbers, dates, URLs, etc.)\n              * Include context about where data might be located\n\n        website_url (Optional[str]): The complete URL of the webpage to scrape.\n            - Mutually exclusive with website_html and website_markdown\n            - Must include protocol (http:// or https://)\n            - Supports dynamic and static content\n            - Examples:\n              * https://example.com/products/item\n              * https://news.site.com/article/123\n              * https://company.com/contact\n            - Default: None (must provide one of the three input sources)\n\n        website_html (Optional[str]): Raw HTML content to process locally.\n            - Mutually exclusive with website_url and website_markdown\n            - Maximum size: 2MB\n            - Useful for processing pre-fetched or generated HTML\n            - Use when you already have HTML content from another source\n            - Example: \"<html><body><h1>Title</h1><p>Content</p></body></html>\"\n            - Default: None\n\n        website_markdown (Optional[str]): Markdown content to process locally.\n            - Mutually exclusive with website_url and website_html\n            - Maximum size: 2MB\n            - Useful for extracting from markdown documents or converted content\n            - Works well with documentation, README files, or converted web content\n            - Example: \"# Title\n\n## Section\n\nContent here...\"\n            - Default: None\n\n        output_schema (Optional[Union[str, Dict]]): JSON schema defining expected output structure.\n            - Can be provided as a dictionary or JSON string\n            - Helps ensure consistent, structured output format\n            - Optional but recommended for complex extractions\n            - IMPORTANT: Must include a \"required\" field (can be empty array [] if no fields are required)\n            - Examples:\n              * As dict: {'type': 'object', 'properties': {'title': {'type': 'string'}, 'price': {'type': 'number'}}, 'required': []}\n              * As JSON string: '{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}, \"required\": []}'\n              * For arrays: {'type': 'array', 'items': {'type': 'object', 'properties': {...}, 'required': []}, 'required': []}\n              * With required fields: {'type': 'object', 'properties': {'name': {'type': 'string'}, 'email': {'type': 'string'}}, 'required': ['name', 'email']}\n            - Note: If \"required\" field is missing, it will be automatically added as an empty array []\n            - Default: None (AI will infer structure from prompt)\n\n        number_of_scrolls (Optional[int]): Number of infinite scrolls to perform before scraping.\n            - Range: 0-50 scrolls\n            - Default: 0 (no scrolling)\n            - Useful for dynamically loaded content (lazy loading, infinite scroll)\n            - Each scroll waits for content to load before continuing\n            - Examples:\n              * 0: Static content, no scrolling needed\n              * 3: Social media feeds, product listings\n              * 10: Long articles, extensive product catalogs\n            - Note: Increases processing time proportionally\n\n        total_pages (Optional[int]): Number of pages to process for pagination.\n            - Range: 1-100 pages\n            - Default: 1 (single page only)\n            - Automatically follows pagination links when available\n            - Useful for multi-page listings, search results, catalogs\n            - Examples:\n              * 1: Single page extraction\n              * 5: First 5 pages of search results\n              * 20: Comprehensive catalog scraping\n            - Note: Each page counts toward credit usage (10 credits \u00d7 pages)\n\n        render_heavy_js (Optional[bool]): Enable heavy JavaScript rendering for dynamic sites.\n            - Default: false\n            - Set to true for Single Page Applications (SPAs), React apps, Vue.js sites\n            - Increases processing time but captures client-side rendered content\n            - Use when content is loaded dynamically via JavaScript\n            - Examples of when to use:\n              * React/Angular/Vue applications\n              * Sites with dynamic content loading\n              * AJAX-heavy interfaces\n              * Content that appears after page load\n            - Note: Significantly increases processing time (30-60 seconds vs 5-15 seconds)\n\n        stealth (Optional[bool]): Enable stealth mode to avoid bot detection.\n            - Default: false\n            - Helps bypass basic anti-scraping measures\n            - Uses techniques to appear more like a human browser\n            - Useful for sites with bot detection systems\n            - Examples of when to use:\n              * Sites that block automated requests\n              * E-commerce sites with protection\n              * Sites that require \"human-like\" behavior\n            - Note: May increase processing time and is not 100% guaranteed\n\n    Returns:\n        Dictionary containing:\n        - extracted_data: The structured data matching your prompt and optional schema\n        - metadata: Information about the extraction process\n        - credits_used: Number of credits consumed (10 per page processed)\n        - processing_time: Time taken for the extraction\n        - pages_processed: Number of pages that were analyzed\n        - status: Success/error status of the operation\n\n    Raises:\n        ValueError: If no input source provided or multiple sources provided\n        HTTPError: If website_url cannot be accessed\n        TimeoutError: If processing exceeds timeout limits\n        ValidationError: If output_schema is malformed JSON\n    ",
      "inputSchema": {
        "type": "object",
        "required": [
          "user_prompt"
        ],
        "properties": {
          "stealth": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "total_pages": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "user_prompt": {
            "type": "string"
          },
          "website_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "website_html": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "output_schema": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "object",
                    "additionalProperties": true
                  }
                ],
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "object"
                  }
                ],
                "default": null,
                "description": "JSON schema dict or JSON string defining the expected output structure"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "render_heavy_js": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "website_markdown": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "number_of_scrolls": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "searchscraper",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": false,
        "destructiveHint": false
      },
      "description": "Perform AI-powered web searches with structured data extraction.\n\nThis tool searches the web based on your query and uses AI to extract structured information\nfrom the search results. Ideal for research, competitive analysis, and gathering information\nfrom multiple sources. Each website searched costs 10 credits (default 3 websites = 30 credits).\nRead-only operation but results may vary over time (non-idempotent).\n\nArgs:\n    user_prompt (str): Search query or natural language instructions for information to find.\n        - Can be a simple search query or detailed extraction instructions\n        - The AI will search the web and extract relevant data from found pages\n        - Be specific about what information you want extracted\n        - Examples:\n          * \"Find latest AI research papers published in 2024 with author names and abstracts\"\n          * \"Search for Python web scraping tutorials with ratings and difficulty levels\"\n          * \"Get current cryptocurrency prices and market caps for top 10 coins\"\n          * \"Find contact information for tech startups in San Francisco\"\n          * \"Search for job openings for data scientists with salary information\"\n        - Tips for better results:\n          * Include specific fields you want extracted\n          * Mention timeframes or filters (e.g., \"latest\", \"2024\", \"top 10\")\n          * Specify data types needed (prices, dates, ratings, etc.)\n\n    num_results (Optional[int]): Number of websites to search and extract data from.\n        - Default: 3 websites (costs 30 credits total)\n        - Range: 1-20 websites (recommended to stay under 10 for cost efficiency)\n        - Each website costs 10 credits, so total cost = num_results \u00d7 10\n        - Examples:\n          * 1: Quick single-source lookup (10 credits)\n          * 3: Standard research (30 credits) - good balance of coverage and cost\n          * 5: Comprehensive research (50 credits)\n          * 10: Extensive analysis (100 credits)\n        - Note: More results provide broader coverage but increase costs and processing time\n\n    number_of_scrolls (Optional[int]): Number of infinite scrolls per searched webpage.\n        - Default: 0 (no scrolling on search result pages)\n        - Range: 0-10 scrolls per page\n        - Useful when search results point to pages with dynamic content loading\n        - Each scroll waits for content to load before continuing\n        - Examples:\n          * 0: Static content pages, news articles, documentation\n          * 2: Social media pages, product listings with lazy loading\n          * 5: Extensive feeds, long-form content with infinite scroll\n        - Note: Increases processing time significantly (adds 5-10 seconds per scroll per page)\n\nReturns:\n    Dictionary containing:\n    - search_results: Array of extracted data from each website found\n    - sources: List of URLs that were searched and processed\n    - total_websites_processed: Number of websites successfully analyzed\n    - credits_used: Total credits consumed (num_results \u00d7 10)\n    - processing_time: Total time taken for search and extraction\n    - search_query_used: The actual search query sent to search engines\n    - metadata: Additional information about the search process\n\nRaises:\n    ValueError: If user_prompt is empty or num_results is out of range\n    HTTPError: If search engines are unavailable or return errors\n    TimeoutError: If search or extraction process exceeds timeout limits\n    RateLimitError: If too many requests are made in a short time period\n\nNote:\n    - Results may vary between calls due to changing web content (non-idempotent)\n    - Search engines may return different results over time\n    - Some websites may be inaccessible or block automated access\n    - Processing time increases with num_results and number_of_scrolls\n    - Consider using smartscraper on specific URLs if you know the target sites",
      "inputSchema": {
        "type": "object",
        "required": [
          "user_prompt"
        ],
        "properties": {
          "num_results": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "user_prompt": {
            "type": "string"
          },
          "number_of_scrolls": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "smartcrawler_initiate",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": false,
        "idempotentHint": false,
        "destructiveHint": false
      },
      "description": "Initiate an asynchronous multi-page web crawling operation with AI extraction or markdown conversion.\n\nThis tool starts an intelligent crawler that discovers and processes multiple pages from a starting URL.\nChoose between AI Extraction Mode (10 credits/page) for structured data or Markdown Mode (2 credits/page)\nfor content conversion. The operation is asynchronous - use smartcrawler_fetch_results to retrieve results.\nCreates a new crawl request (non-idempotent, non-read-only).\n\nSmartCrawler supports two modes:\n- AI Extraction Mode: Extracts structured data based on your prompt from every crawled page\n- Markdown Conversion Mode: Converts each page to clean markdown format\n\nArgs:\n    url (str): The starting URL to begin crawling from.\n        - Must include protocol (http:// or https://)\n        - The crawler will discover and process linked pages from this starting point\n        - Should be a page with links to other pages you want to crawl\n        - Examples:\n          * https://docs.example.com (documentation site root)\n          * https://blog.company.com (blog homepage)\n          * https://example.com/products (product category page)\n          * https://news.site.com/category/tech (news section)\n        - Best practices:\n          * Use homepage or main category pages as starting points\n          * Ensure the starting page has links to content you want to crawl\n          * Consider site structure when choosing the starting URL\n\n    prompt (Optional[str]): AI prompt for data extraction.\n        - REQUIRED when extraction_mode is 'ai'\n        - Ignored when extraction_mode is 'markdown'\n        - Describes what data to extract from each crawled page\n        - Applied consistently across all discovered pages\n        - Examples:\n          * \"Extract API endpoint name, method, parameters, and description\"\n          * \"Get article title, author, publication date, and summary\"\n          * \"Find product name, price, description, and availability\"\n          * \"Extract job title, company, location, salary, and requirements\"\n        - Tips for better results:\n          * Be specific about fields you want from each page\n          * Consider that different pages may have different content structures\n          * Use general terms that apply across multiple page types\n\n    extraction_mode (str): Extraction mode for processing crawled pages.\n        - Default: \"ai\"\n        - Options:\n          * \"ai\": AI-powered structured data extraction (10 credits per page)\n            - Uses the prompt to extract specific data from each page\n            - Returns structured JSON data\n            - More expensive but provides targeted information\n            - Best for: Data collection, research, structured analysis\n          * \"markdown\": Simple markdown conversion (2 credits per page)\n            - Converts each page to clean markdown format\n            - No AI processing, just content conversion\n            - More cost-effective for content archival\n            - Best for: Documentation backup, content migration, reading\n        - Cost comparison:\n          * AI mode: 50 pages = 500 credits\n          * Markdown mode: 50 pages = 100 credits\n\n    depth (Optional[int]): Maximum depth of link traversal from the starting URL.\n        - Default: unlimited (will follow links until max_pages or no more links)\n        - Depth levels:\n          * 0: Only the starting URL (no link following)\n          * 1: Starting URL + pages directly linked from it\n          * 2: Starting URL + direct links + links from those pages\n          * 3+: Continues following links to specified depth\n        - Examples:\n          * 1: Crawl blog homepage + all blog posts\n          * 2: Crawl docs homepage + category pages + individual doc pages\n          * 3: Deep crawling for comprehensive site coverage\n        - Considerations:\n          * Higher depth can lead to exponential page growth\n          * Use with max_pages to control scope and cost\n          * Consider site structure when setting depth\n\n    max_pages (Optional[int]): Maximum number of pages to crawl in total.\n        - Default: unlimited (will crawl until no more links or depth limit)\n        - Recommended ranges:\n          * 10-20: Testing and small sites\n          * 50-100: Medium sites and focused crawling\n          * 200-500: Large sites and comprehensive analysis\n          * 1000+: Enterprise-level crawling (high cost)\n        - Cost implications:\n          * AI mode: max_pages \u00d7 10 credits\n          * Markdown mode: max_pages \u00d7 2 credits\n        - Examples:\n          * 10: Quick site sampling (20-100 credits)\n          * 50: Standard documentation crawl (100-500 credits)\n          * 200: Comprehensive site analysis (400-2000 credits)\n        - Note: Crawler stops when this limit is reached, regardless of remaining links\n\n    same_domain_only (Optional[bool]): Whether to crawl only within the same domain.\n        - Default: true (recommended for most use cases)\n        - Options:\n          * true: Only crawl pages within the same domain as starting URL\n            - Prevents following external links\n            - Keeps crawling focused on the target site\n            - Reduces risk of crawling unrelated content\n            - Example: Starting at docs.example.com only crawls docs.example.com pages\n          * false: Allow crawling external domains\n            - Follows links to other domains\n            - Can lead to very broad crawling scope\n            - May crawl unrelated or unwanted content\n            - Use with caution and appropriate max_pages limit\n        - Recommendations:\n          * Use true for focused site crawling\n          * Use false only when you specifically need cross-domain data\n          * Always set max_pages when using false to prevent runaway crawling\n\nReturns:\n    Dictionary containing:\n    - request_id: Unique identifier for this crawl operation (use with smartcrawler_fetch_results)\n    - status: Initial status of the crawl request (\"initiated\" or \"processing\")\n    - estimated_cost: Estimated credit cost based on parameters (actual cost may vary)\n    - crawl_parameters: Summary of the crawling configuration\n    - estimated_time: Rough estimate of processing time\n    - next_steps: Instructions for retrieving results\n\nRaises:\n    ValueError: If URL is malformed, prompt is missing for AI mode, or parameters are invalid\n    HTTPError: If the starting URL cannot be accessed\n    RateLimitError: If too many crawl requests are initiated too quickly\n\nNote:\n    - This operation is asynchronous and may take several minutes to complete\n    - Use smartcrawler_fetch_results with the returned request_id to get results\n    - Keep polling smartcrawler_fetch_results until status is \"completed\"\n    - Actual pages crawled may be less than max_pages if fewer links are found\n    - Processing time increases with max_pages, depth, and extraction_mode complexity",
      "inputSchema": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string"
          },
          "depth": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "max_pages": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "extraction_mode": {
            "type": "string",
            "default": "ai"
          },
          "same_domain_only": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "smartcrawler_fetch_results",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": true,
        "destructiveHint": false
      },
      "description": "Retrieve the results of an asynchronous SmartCrawler operation.\n\nThis tool fetches the results from a previously initiated crawling operation using the request_id.\nThe crawl request processes asynchronously in the background. Keep polling this endpoint until\nthe status field indicates 'completed'. While processing, you'll receive status updates.\nRead-only operation that safely retrieves results without side effects.\n\nArgs:\n    request_id: The unique request ID returned by smartcrawler_initiate. Use this to retrieve the crawling results. Keep polling until status is 'completed'. Example: 'req_abc123xyz'\n\nReturns:\n    Dictionary containing:\n    - status: Current status of the crawl operation ('processing', 'completed', 'failed')\n    - results: Crawled data (structured extraction or markdown) when completed\n    - metadata: Information about processed pages, URLs visited, and processing statistics\n    Keep polling until status is 'completed' to get final results",
      "inputSchema": {
        "type": "object",
        "required": [
          "request_id"
        ],
        "properties": {
          "request_id": {
            "type": "string"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "scrape",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": true,
        "destructiveHint": false
      },
      "description": "Fetch raw page content from any URL with optional JavaScript rendering.\n\nThis tool performs basic web scraping to retrieve the raw HTML content of a webpage.\nOptionally enable JavaScript rendering for Single Page Applications (SPAs) and sites with\nheavy client-side rendering. Lower cost than AI extraction (1 credit/page).\nRead-only operation with no side effects.\n\nArgs:\n    website_url (str): The complete URL of the webpage to scrape.\n        - Must include protocol (http:// or https://)\n        - Returns raw HTML content of the page\n        - Works with both static and dynamic websites\n        - Examples:\n          * https://example.com/page\n          * https://api.example.com/docs\n          * https://news.site.com/article/123\n          * https://app.example.com/dashboard (may need render_heavy_js=true)\n        - Supported protocols: HTTP, HTTPS\n        - Invalid examples:\n          * example.com (missing protocol)\n          * ftp://example.com (unsupported protocol)\n\n    render_heavy_js (Optional[bool]): Enable full JavaScript rendering for dynamic content.\n        - Default: false (faster, lower cost, works for most static sites)\n        - Set to true for sites that require JavaScript execution to display content\n        - When to use true:\n          * Single Page Applications (React, Angular, Vue.js)\n          * Sites with dynamic content loading via AJAX\n          * Content that appears only after JavaScript execution\n          * Interactive web applications\n          * Sites where initial HTML is mostly empty\n        - When to use false (default):\n          * Static websites and blogs\n          * Server-side rendered content\n          * Traditional HTML pages\n          * News articles and documentation\n          * When you need faster processing\n        - Performance impact:\n          * false: 2-5 seconds processing time\n          * true: 15-30 seconds processing time (waits for JS execution)\n        - Cost: Same (1 credit) regardless of render_heavy_js setting\n\nReturns:\n    Dictionary containing:\n    - html_content: The raw HTML content of the page as a string\n    - page_title: Extracted page title if available\n    - status_code: HTTP response status code (200 for success)\n    - final_url: Final URL after any redirects\n    - content_length: Size of the HTML content in bytes\n    - processing_time: Time taken to fetch and process the page\n    - javascript_rendered: Whether JavaScript rendering was used\n    - credits_used: Number of credits consumed (always 1)\n\nRaises:\n    ValueError: If website_url is malformed or missing protocol\n    HTTPError: If the webpage returns an error status (404, 500, etc.)\n    TimeoutError: If the page takes too long to load\n    ConnectionError: If the website cannot be reached\n\nUse Cases:\n    - Getting raw HTML for custom parsing\n    - Checking page structure before using other tools\n    - Fetching content for offline processing\n    - Debugging website content issues\n    - Pre-processing before AI extraction\n\nNote:\n    - This tool returns raw HTML without any AI processing\n    - Use smartscraper for structured data extraction\n    - Use markdownify for clean, readable content\n    - Consider render_heavy_js=true if initial results seem incomplete",
      "inputSchema": {
        "type": "object",
        "required": [
          "website_url"
        ],
        "properties": {
          "website_url": {
            "type": "string"
          },
          "render_heavy_js": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "sitemap",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": true,
        "idempotentHint": true,
        "destructiveHint": false
      },
      "description": "Extract and discover the complete sitemap structure of any website.\n\nThis tool automatically discovers all accessible URLs and pages within a website, providing\na comprehensive map of the site's structure. Useful for understanding site architecture before\ncrawling or for discovering all available content. Very cost-effective at 1 credit per request.\nRead-only operation with no side effects.\n\nArgs:\n    website_url (str): The base URL of the website to extract sitemap from.\n        - Must include protocol (http:// or https://)\n        - Should be the root domain or main section you want to map\n        - The tool will discover all accessible pages from this starting point\n        - Examples:\n          * https://example.com (discover entire website structure)\n          * https://docs.example.com (map documentation site)\n          * https://blog.company.com (discover all blog pages)\n          * https://shop.example.com (map e-commerce structure)\n        - Best practices:\n          * Use root domain (https://example.com) for complete site mapping\n          * Use subdomain (https://docs.example.com) for focused mapping\n          * Ensure the URL is accessible and doesn't require authentication\n        - Discovery methods:\n          * Checks for robots.txt and sitemap.xml files\n          * Crawls navigation links and menus\n          * Discovers pages through internal link analysis\n          * Identifies common URL patterns and structures\n\nReturns:\n    Dictionary containing:\n    - discovered_urls: List of all URLs found on the website\n    - site_structure: Hierarchical organization of pages and sections\n    - url_categories: URLs grouped by type (pages, images, documents, etc.)\n    - total_pages: Total number of pages discovered\n    - subdomains: List of subdomains found (if any)\n    - sitemap_sources: Sources used for discovery (sitemap.xml, robots.txt, crawling)\n    - page_types: Breakdown of different content types found\n    - depth_analysis: URL organization by depth from root\n    - external_links: Links pointing to external domains (if found)\n    - processing_time: Time taken to complete the discovery\n    - credits_used: Number of credits consumed (always 1)\n\nRaises:\n    ValueError: If website_url is malformed or missing protocol\n    HTTPError: If the website cannot be accessed or returns errors\n    TimeoutError: If the discovery process takes too long\n    ConnectionError: If the website cannot be reached\n\nUse Cases:\n    - Planning comprehensive crawling operations\n    - Understanding website architecture and organization\n    - Discovering all available content before targeted scraping\n    - SEO analysis and site structure optimization\n    - Content inventory and audit preparation\n    - Identifying pages for bulk processing operations\n\nBest Practices:\n    - Run sitemap before using smartcrawler_initiate for better planning\n    - Use results to set appropriate max_pages and depth parameters\n    - Check discovered URLs to understand site organization\n    - Identify high-value pages for targeted extraction\n    - Use for cost estimation before large crawling operations\n\nNote:\n    - Very cost-effective at only 1 credit per request\n    - Results may vary based on site structure and accessibility\n    - Some pages may require authentication and won't be discovered\n    - Large sites may have thousands of URLs - consider filtering results\n    - Use discovered URLs as input for other scraping tools",
      "inputSchema": {
        "type": "object",
        "required": [
          "website_url"
        ],
        "properties": {
          "website_url": {
            "type": "string"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    },
    {
      "name": "agentic_scrapper",
      "_meta": {
        "_fastmcp": {
          "tags": []
        }
      },
      "annotations": {
        "readOnlyHint": false,
        "idempotentHint": false,
        "destructiveHint": false
      },
      "description": "Execute complex multi-step web scraping workflows with AI-powered automation.\n\nThis tool runs an intelligent agent that can navigate websites, interact with forms and buttons,\nfollow multi-step workflows, and extract structured data. Ideal for complex scraping scenarios\nrequiring user interaction simulation, form submissions, or multi-page navigation flows.\nSupports custom output schemas and step-by-step instructions. Variable credit cost based on\ncomplexity. Can perform actions on the website (non-read-only, non-idempotent).\n\nThe agent accepts flexible input formats for steps (list or JSON string) and output_schema\n(dict or JSON string) to accommodate different client implementations.\n\nArgs:\n    url (str): The target website URL where the agentic scraping workflow should start.\n        - Must include protocol (http:// or https://)\n        - Should be the starting page for your automation workflow\n        - The agent will begin its actions from this URL\n        - Examples:\n          * https://example.com/search (start at search page)\n          * https://shop.example.com/login (begin with login flow)\n          * https://app.example.com/dashboard (start at main interface)\n          * https://forms.example.com/contact (begin at form page)\n        - Considerations:\n          * Choose a starting point that makes sense for your workflow\n          * Ensure the page is publicly accessible or handle authentication\n          * Consider the logical flow of actions from this starting point\n\n    user_prompt (Optional[str]): High-level instructions for what the agent should accomplish.\n        - Describes the overall goal and desired outcome of the automation\n        - Should be clear and specific about what you want to achieve\n        - Works in conjunction with the steps parameter for detailed guidance\n        - Examples:\n          * \"Navigate to the search page, search for laptops, and extract the top 5 results with prices\"\n          * \"Fill out the contact form with sample data and submit it\"\n          * \"Login to the dashboard and extract all recent notifications\"\n          * \"Browse the product catalog and collect information about all items\"\n          * \"Navigate through the multi-step checkout process and capture each step\"\n        - Tips for better results:\n          * Be specific about the end goal\n          * Mention what data you want extracted\n          * Include context about the expected workflow\n          * Specify any particular elements or sections to focus on\n\n    output_schema (Optional[Union[str, Dict]]): Desired output structure for extracted data.\n        - Can be provided as a dictionary or JSON string\n        - Defines the format and structure of the final extracted data\n        - Helps ensure consistent, predictable output format\n        - IMPORTANT: Must include a \"required\" field (can be empty array [] if no fields are required)\n        - Examples:\n          * Simple object: {'type': 'object', 'properties': {'title': {'type': 'string'}, 'price': {'type': 'number'}}, 'required': []}\n          * Array of objects: {'type': 'array', 'items': {'type': 'object', 'properties': {'name': {'type': 'string'}, 'value': {'type': 'string'}}, 'required': []}, 'required': []}\n          * Complex nested: {'type': 'object', 'properties': {'products': {'type': 'array', 'items': {...}}, 'total_count': {'type': 'number'}}, 'required': []}\n          * As JSON string: '{\"type\": \"object\", \"properties\": {\"results\": {\"type\": \"array\"}}, \"required\": []}'\n          * With required fields: {'type': 'object', 'properties': {'id': {'type': 'string'}, 'name': {'type': 'string'}}, 'required': ['id']}\n        - Note: If \"required\" field is missing, it will be automatically added as an empty array []\n        - Default: None (agent will infer structure from prompt and steps)\n\n    steps (Optional[Union[str, List[str]]]): Step-by-step instructions for the agent.\n        - Can be provided as a list of strings or JSON array string\n        - Provides detailed, sequential instructions for the automation workflow\n        - Each step should be a clear, actionable instruction\n        - Examples as list:\n          * ['Click the search button', 'Enter \"laptops\" in the search box', 'Press Enter', 'Wait for results to load', 'Extract product information']\n          * ['Fill in email field with test@example.com', 'Fill in password field', 'Click login button', 'Navigate to profile page']\n        - Examples as JSON string:\n          * '[\"Open navigation menu\", \"Click on Products\", \"Select category filters\", \"Extract all product data\"]'\n        - Best practices:\n          * Break complex actions into simple steps\n          * Be specific about UI elements (button text, field names, etc.)\n          * Include waiting/loading steps when necessary\n          * Specify extraction points clearly\n          * Order steps logically for the workflow\n\n    ai_extraction (Optional[bool]): Enable AI-powered extraction mode for intelligent data parsing.\n        - Default: true (recommended for most use cases)\n        - Options:\n          * true: Uses advanced AI to intelligently extract and structure data\n            - Better at handling complex page layouts\n            - Can adapt to different content structures\n            - Provides more accurate data extraction\n            - Recommended for most scenarios\n          * false: Uses simpler extraction methods\n            - Faster processing but less intelligent\n            - May miss complex or nested data\n            - Use when speed is more important than accuracy\n        - Performance impact:\n          * true: Higher processing time but better results\n          * false: Faster execution but potentially less accurate extraction\n\n    persistent_session (Optional[bool]): Maintain session state between steps.\n        - Default: false (each step starts fresh)\n        - Options:\n          * true: Keeps cookies, login state, and session data between steps\n            - Essential for authenticated workflows\n            - Maintains shopping cart contents, user preferences, etc.\n            - Required for multi-step processes that depend on previous actions\n            - Use for: Login flows, shopping processes, form wizards\n          * false: Each step starts with a clean session\n            - Faster and simpler for independent actions\n            - No state carried between steps\n            - Use for: Simple data extraction, public content scraping\n        - Examples when to use true:\n          * Login \u2192 Navigate to protected area \u2192 Extract data\n          * Add items to cart \u2192 Proceed to checkout \u2192 Extract order details\n          * Multi-step form completion with session dependencies\n\n    timeout_seconds (Optional[float]): Maximum time to wait for the entire workflow.\n        - Default: 120 seconds (2 minutes)\n        - Recommended ranges:\n          * 60-120: Simple workflows (2-5 steps)\n          * 180-300: Medium complexity (5-10 steps)\n          * 300-600: Complex workflows (10+ steps or slow sites)\n          * 600+: Very complex or slow-loading workflows\n        - Considerations:\n          * Include time for page loads, form submissions, and processing\n          * Factor in network latency and site response times\n          * Allow extra time for AI processing and extraction\n          * Balance between thoroughness and efficiency\n        - Examples:\n          * 60.0: Quick single-page data extraction\n          * 180.0: Multi-step form filling and submission\n          * 300.0: Complex navigation and comprehensive data extraction\n          * 600.0: Extensive workflows with multiple page interactions\n\nReturns:\n    Dictionary containing:\n    - extracted_data: The structured data matching your prompt and optional schema\n    - workflow_log: Detailed log of all actions performed by the agent\n    - pages_visited: List of URLs visited during the workflow\n    - actions_performed: Summary of interactions (clicks, form fills, navigations)\n    - execution_time: Total time taken for the workflow\n    - steps_completed: Number of steps successfully executed\n    - final_page_url: The URL where the workflow ended\n    - session_data: Session information if persistent_session was enabled\n    - credits_used: Number of credits consumed (varies by complexity)\n    - status: Success/failure status with any error details\n\nRaises:\n    ValueError: If URL is malformed or required parameters are missing\n    TimeoutError: If the workflow exceeds the specified timeout\n    NavigationError: If the agent cannot navigate to required pages\n    InteractionError: If the agent cannot interact with specified elements\n    ExtractionError: If data extraction fails or returns invalid results\n\nUse Cases:\n    - Automated form filling and submission\n    - Multi-step checkout processes\n    - Login-protected content extraction\n    - Interactive search and filtering workflows\n    - Complex navigation scenarios requiring user simulation\n    - Data collection from dynamic, JavaScript-heavy applications\n\nBest Practices:\n    - Start with simple workflows and gradually increase complexity\n    - Use specific element identifiers in steps (button text, field labels)\n    - Include appropriate wait times for page loads and dynamic content\n    - Test with persistent_session=true for authentication-dependent workflows\n    - Set realistic timeouts based on workflow complexity\n    - Provide clear, sequential steps that build on each other\n    - Use output_schema to ensure consistent data structure\n\nNote:\n    - This tool can perform actions on websites (non-read-only)\n    - Results may vary between runs due to dynamic content (non-idempotent)\n    - Credit cost varies based on workflow complexity and execution time\n    - Some websites may have anti-automation measures that could affect success\n    - Consider using simpler tools (smartscraper, markdownify) for basic extraction needs",
      "inputSchema": {
        "type": "object",
        "required": [
          "url"
        ],
        "properties": {
          "url": {
            "type": "string"
          },
          "steps": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ],
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ],
                "default": null,
                "description": "Step-by-step instructions for the agent as a list of strings or JSON array string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "user_prompt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "ai_extraction": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "output_schema": {
            "anyOf": [
              {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "object",
                    "additionalProperties": true
                  }
                ],
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "object"
                  }
                ],
                "default": null,
                "description": "Desired output structure as a JSON schema dict or JSON string"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "timeout_seconds": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          },
          "persistent_session": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "default": null
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "additionalProperties": true
      }
    }
  ],
  "_sync": {
    "fetched_at": "2026-01-04T13:46:19.430786+00:00",
    "source": "smithery"
  }
}