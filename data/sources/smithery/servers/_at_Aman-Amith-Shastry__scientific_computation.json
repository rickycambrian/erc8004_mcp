{
  "qualifiedName": "@Aman-Amith-Shastry/scientific_computation",
  "displayName": "Scientific Computing",
  "description": "Create and manage tensors to perform linear algebra, matrix decompositions, and vector operations. Analyze systems with determinants, eigenvalues, QR/SVD, projections, and basis changes, and compute gradients, divergence, curl, and Laplacians symbolically. Visualize functions and vector fields to explore behavior and validate results quickly.",
  "iconUrl": "https://icons.duckduckgo.com/ip3/github.com.ico",
  "remote": true,
  "deploymentUrl": "https://server.smithery.ai/@Aman-Amith-Shastry/scientific_computation",
  "connections": [
    {
      "type": "http",
      "deploymentUrl": "https://server.smithery.ai/@Aman-Amith-Shastry/scientific_computation/mcp",
      "configSchema": {
        "type": "object",
        "properties": {}
      }
    }
  ],
  "security": null,
  "tools": [
    {
      "name": "create_tensor",
      "description": "\n    Creates a NumPy array (matrix) with a specified shape and values.\n\n    Args:\n        shape (list[int]): The shape of the resulting array as a tuple(e.g., (2, 3)).\n        values (list[float]): A flat list of values to populate the array.\n        name (str): The name of the tensor to be stored.\n\n    Returns:\n        np.ndarray: A NumPy array with the specified shape.\n\n    Raises:\n        ValueError: If the number of values does not match the product of the shape.\n    ",
      "inputSchema": {
        "type": "object",
        "title": "create_tensorArguments",
        "required": [
          "shape",
          "values",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "shape": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "title": "Shape",
            "minItems": 1,
            "description": "Tensor shape as list of integers"
          },
          "values": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "Values",
            "minItems": 1,
            "description": "Flat list of floats to fill the tensor"
          }
        }
      }
    },
    {
      "name": "view_tensor",
      "description": "\n    Returns an immutable view of a previously stored NumPy tensor from the in-memory tensor store.\n\n    Args:\n        name (str): The name of the tensor as stored in the in-store dictionary\n    Returns:\n        dict: The in-store dictionary for tensors\n\n    ",
      "inputSchema": {
        "type": "object",
        "title": "view_tensorArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "delete_tensor",
      "description": "\n    Deletes a tensor from the in-memory tensor store.\n\n    Args:\n        name (str): The name of the tensor to delete.\n\n    Raises:\n        ValueError: If the tensor name is not found in the store or if an error occurs during deletion.\n    ",
      "inputSchema": {
        "type": "object",
        "title": "delete_tensorArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "add_matrices",
      "description": "\n        Adds two stored tensors element-wise.\n\n        Args:\n            name_a (str): The name of the first tensor.\n            name_b (str): The name of the second tensor.\n\n        Returns:\n            np.ndarray: The result of element-wise addition.\n\n        Raises:\n            ValueError: If the tensor names are not found or shapes are incompatible.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "add_matricesArguments",
        "required": [
          "name_a",
          "name_b"
        ],
        "properties": {
          "name_a": {
            "type": "string",
            "title": "Name A"
          },
          "name_b": {
            "type": "string",
            "title": "Name B"
          }
        }
      }
    },
    {
      "name": "subtract_matrices",
      "description": "\n        Adds two stored tensors element-wise.\n\n        Args:\n            name_a (str): The name of the first tensor.\n            name_b (str): The name of the second tensor.\n\n        Returns:\n            np.ndarray: The result of element-wise subtraction.\n\n        Raises:\n            ValueError: If the tensor names are not found or shapes are incompatible.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "subtract_matricesArguments",
        "required": [
          "name_a",
          "name_b"
        ],
        "properties": {
          "name_a": {
            "type": "string",
            "title": "Name A"
          },
          "name_b": {
            "type": "string",
            "title": "Name B"
          }
        }
      }
    },
    {
      "name": "multiply_matrices",
      "description": "\n        Performs matrix multiplication between two stored tensors.\n\n        Args:\n            name_a (str): The name of the first tensor.\n            name_b (str): The name of the second tensor.\n\n        Returns:\n            np.ndarray: The result of matrix multiplication.\n\n        Raises:\n            ValueError: If either tensor is not found or their shapes are incompatible.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "multiply_matricesArguments",
        "required": [
          "name_a",
          "name_b"
        ],
        "properties": {
          "name_a": {
            "type": "string",
            "title": "Name A"
          },
          "name_b": {
            "type": "string",
            "title": "Name B"
          }
        }
      }
    },
    {
      "name": "scale_matrix",
      "description": "\n        Scales a stored tensor by a scalar factor.\n\n        Args:\n            name (str): The name of the tensor to scale.\n            scale_factor (float): The scalar value to multiply the tensor by.\n            in_place (bool): If True, updates the stored tensor; otherwise, returns a new scaled tensor.\n\n        Returns:\n            np.ndarray: The scaled tensor.\n\n        Raises:\n            ValueError: If the tensor name is not found in the store.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "scale_matrixArguments",
        "required": [
          "name",
          "scale_factor"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "in_place": {
            "type": "boolean",
            "title": "In Place",
            "default": true
          },
          "scale_factor": {
            "type": "number",
            "title": "Scale Factor"
          }
        }
      }
    },
    {
      "name": "matrix_inverse",
      "description": "\n        Computes the inverse of a stored square matrix.\n\n        Args:\n            name (str): The name of the tensor to invert.\n\n        Returns:\n            np.ndarray: The inverse of the matrix.\n\n        Raises:\n            ValueError: If the matrix is not found, is not square, or is singular (non-invertible).\n        ",
      "inputSchema": {
        "type": "object",
        "title": "matrix_inverseArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "transpose",
      "description": "\n        Computes the transpose of a stored tensor.\n\n        Args:\n            name (str): The name of the tensor to transpose.\n\n        Returns:\n            np.ndarray: The transposed tensor.\n\n        Raises:\n            ValueError: If the tensor name is not found in the store.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "transposeArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "determinant",
      "description": "\n        Computes the determinant of a stored square matrix.\n\n        Args:\n            name (str): The name of the matrix.\n\n        Returns:\n            float: The determinant of the matrix.\n\n        Raises:\n            ValueError: If the matrix is not found or is not square.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "determinantArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "determinantOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "number",
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "rank",
      "description": "\n        Computes the rank of a stored tensor.\n\n        Args:\n            name (str): The name of the tensor.\n\n        Returns:\n            int | list[int]: The rank of the matrix.\n\n        Raises:\n            ValueError: If the tensor name is not found in the store.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "rankArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "rankOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "array",
                "items": {
                  "type": "integer"
                }
              }
            ],
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "compute_eigen",
      "description": "\n        Computes the eigenvalues and right eigenvectors of a stored square matrix.\n\n        Args:\n            name (str): The name of the tensor to analyze.\n\n        Returns:\n            dict: A dictionary with keys:\n                - 'eigenvalues': np.ndarray\n                - 'eigenvectors': np.ndarray\n\n        Raises:\n            ValueError: If the tensor is not found or is not a square matrix.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "compute_eigenArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "qr_decompose",
      "description": "\n        Computes the QR decomposition of a stored matrix.\n\n        Decomposes the matrix A into A = Q @ R, where Q is an orthogonal matrix\n        and R is an upper triangular matrix.\n\n        Args:\n            name (str): The name of the matrix to decompose.\n\n        Returns:\n            dict: A dictionary with keys:\n                - 'q': np.ndarray, the orthogonal matrix Q\n                - 'r': np.ndarray, the upper triangular matrix R\n\n        Raises:\n            ValueError: If the matrix is not found or decomposition fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "qr_decomposeArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "svd_decompose",
      "description": "\n        Computes the Singular Value Decomposition (SVD) of a stored matrix.\n\n        Decomposes the matrix A into A = U @ S @ V^T, where U and V^T are orthogonal\n        matrices, and S is a diagonal matrix of singular values.\n\n        Args:\n            name (str): The name of the matrix to decompose.\n\n        Returns:\n            dict: A dictionary with keys:\n                - 'u': np.ndarray, the left singular vectors\n                - 's': np.ndarray, the singular values\n                - 'v_t': np.ndarray, the right singular vectors transposed\n\n        Raises:\n            ValueError: If the matrix is not found or decomposition fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "svd_decomposeArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      }
    },
    {
      "name": "find_orthonormal_basis",
      "description": "\n        Finds an orthonormal basis for the column space of a stored matrix using QR decomposition.\n\n        Args:\n            name (str): The name of the matrix.\n\n        Returns:\n            list[list[float]]: A list of orthonormal basis vectors.\n\n        Raises:\n            ValueError: If the matrix is not found or decomposition fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "find_orthonormal_basisArguments",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "find_orthonormal_basisOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "change_basis",
      "description": "\n        Changes the basis of a stored square matrix.\n\n        Args:\n            name (str): Name of the matrix in the tensor store.\n            new_basis (list[list[float]]): Columns are new basis vectors.\n\n        Returns:\n            np.ndarray: Representation of the matrix in the new basis.\n\n        Raises:\n            ValueError: If the matrix name is not found or non-invertible.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "change_basisArguments",
        "required": [
          "name",
          "new_basis"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "new_basis": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number"
              }
            },
            "title": "New Basis"
          }
        }
      }
    },
    {
      "name": "vector_project",
      "description": "\n        Projects a stored vector onto another vector.\n\n        Args:\n            name (str): Name of the stored vector to project.\n            new_vector (list[float]): The vector to project onto.\n\n        Returns:\n            np.ndarray: The projection result vector.\n\n        Raises:\n            ValueError: If the vector name is not found or projection fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "vector_projectArguments",
        "required": [
          "name",
          "new_vector"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "new_vector": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "New Vector"
          }
        }
      }
    },
    {
      "name": "vector_dot_product",
      "description": "\n        Computes the dot product between two stored vectors.\n\n        Args:\n            name_a (str): Name of the first vector in the tensor store.\n            name_b (str): Name of the second vector in the tensor store.\n\n        Returns:\n            np.ndarray: Scalar result of the dot product.\n\n        Raises:\n            ValueError: If either vector is not found or if the dot product computation fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "vector_dot_productArguments",
        "required": [
          "name_a",
          "name_b"
        ],
        "properties": {
          "name_a": {
            "type": "string",
            "title": "Name A"
          },
          "name_b": {
            "type": "string",
            "title": "Name B"
          }
        }
      }
    },
    {
      "name": "vector_cross_product",
      "description": "\n        Computes the cross product of two stored vectors.\n\n        Args:\n            name_a (str): Name of the first vector in the tensor store.\n            name_b (str): Name of the second vector in the tensor store.\n\n        Returns:\n            np.ndarray: Vector result of the cross product.\n\n        Raises:\n            ValueError: If either vector is not found or if the cross product computation fails.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "vector_cross_productArguments",
        "required": [
          "name_a",
          "name_b"
        ],
        "properties": {
          "name_a": {
            "type": "string",
            "title": "Name A"
          },
          "name_b": {
            "type": "string",
            "title": "Name B"
          }
        }
      }
    },
    {
      "name": "gradient",
      "description": "\n        Computes the symbolic gradient of a scalar function.\n\n        Args:\n            f_str (str): A string representing a scalar function (e.g., \"x**2 + y*z\").\n\n        Returns:\n            str: A string representation of the symbolic gradient as a vector.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "gradientArguments",
        "required": [
          "f_str"
        ],
        "properties": {
          "f_str": {
            "type": "string",
            "title": "F Str"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "gradientOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "string",
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "curl",
      "description": "\n        Computes the symbolic curl of a vector field, optionally evaluated at a point.\n\n        Args:\n            f_str (str): A string representing the vector field in list format (e.g., \"[x+y, x, 2*z]\").\n            point (list[float], optional): A list of coordinates [x, y, z] to evaluate the curl numerically.\n\n        Returns:\n            dict: A dictionary with the symbolic curl as a string, and optionally the evaluated vector.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "curlArguments",
        "required": [
          "f_str"
        ],
        "properties": {
          "f_str": {
            "type": "string",
            "title": "F Str"
          },
          "point": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "Point",
            "default": null
          }
        }
      }
    },
    {
      "name": "divergence",
      "description": "\n        Computes the symbolic divergence of a vector field, optionally evaluated at a point.\n\n        Args:\n            f_str (str): A string representing the vector field in list format (e.g., \"[x+y, x, 2*z]\").\n            point (list[float], optional): A list of coordinates [x, y, z] to evaluate the divergence numerically.\n\n        Returns:\n            dict: A dictionary with the symbolic divergence as a string, and optionally the evaluated scalar.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "divergenceArguments",
        "required": [
          "f_str"
        ],
        "properties": {
          "f_str": {
            "type": "string",
            "title": "F Str"
          },
          "point": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "Point",
            "default": null
          }
        }
      }
    },
    {
      "name": "laplacian",
      "description": "\n        Computes the Laplacian of a scalar or vector field symbolically.\n\n        Args:\n            f_str (str): Scalar function as \"x**2 + y*z\" or vector \"[Fx, Fy, Fz]\".\n            is_vector (bool): Set True to compute vector Laplacian.\n\n        Returns:\n            str: Symbolic result of the Laplacian\u2014scalar or list of 3 components.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "laplacianArguments",
        "required": [
          "f_str"
        ],
        "properties": {
          "f_str": {
            "type": "string",
            "title": "F Str"
          },
          "is_vector": {
            "type": "boolean",
            "title": "Is Vector",
            "default": false
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "laplacianOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "string",
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "directional_deriv",
      "description": "\n        Computes symbolic directional derivative of scalar field along a vector direction.\n\n        Args: f_str (str): Expression like \"x*y*z\". u (list[float]): Direction vector [vx, vy, vz]. unit (bool): True\n        if u should be normalized before calculating directional derivative. Set to True by default.\n\n        Returns:\n            str: Symbolic result as string.\n        ",
      "inputSchema": {
        "type": "object",
        "title": "directional_derivArguments",
        "required": [
          "f_str",
          "u"
        ],
        "properties": {
          "u": {
            "type": "array",
            "items": {
              "type": "number"
            },
            "title": "U"
          },
          "unit": {
            "type": "boolean",
            "title": "Unit",
            "default": true
          },
          "f_str": {
            "type": "string",
            "title": "F Str"
          }
        }
      },
      "outputSchema": {
        "type": "object",
        "title": "directional_derivOutput",
        "required": [
          "result"
        ],
        "properties": {
          "result": {
            "type": "string",
            "title": "Result"
          }
        }
      }
    },
    {
      "name": "plot_vector_field",
      "description": "\n        Plots a 3D vector field from a string \"[u(x,y,z), v(x,y,z), w(x,y,z)]\"\n\n        Args:\n            f_str: string representation of 3D field, e.g. \"[z, -y, x]\".\n            bounds: (xmin, xmax, ymin, ymax, zmin, zmax)\n            n: grid resolution per axis\n\n        Returns: Displayed Matplotlib 3D quiver plot (no image return needed)\n        ",
      "inputSchema": {
        "type": "object",
        "title": "plot_vector_fieldArguments",
        "required": [
          "f_str"
        ],
        "properties": {
          "n": {
            "type": "integer",
            "title": "N",
            "default": 10
          },
          "f_str": {
            "type": "string",
            "title": "F Str"
          },
          "bounds": {
            "type": "string",
            "title": "bounds",
            "default": [
              -1,
              1,
              -1,
              1,
              -1,
              1
            ]
          }
        }
      }
    },
    {
      "name": "plot_function",
      "description": "\n        Plots a 2D or 3D mathematical function from a symbolic expression string.\n\n        Args:\n            expr_str: string representation of a function in x or x and y,\n                      e.g. \"x**2\" or \"sin(sqrt(x**2 + y**2))\"\n            xlim: (xmin, xmax) range for x-axis\n            ylim: (ymin, ymax) range for y-axis (used in 2D or 3D)\n            grid: resolution of the plot grid\n\n        Returns:\n            A rendered Image of the function using Matplotlib.\n            - 2D plot if the expression contains only x\n            - 3D surface plot if the expression contains both x and y\n        ",
      "inputSchema": {
        "type": "object",
        "title": "plot_functionArguments",
        "required": [
          "expr_str"
        ],
        "properties": {
          "grid": {
            "type": "string",
            "title": "grid",
            "default": 200
          },
          "xlim": {
            "type": "array",
            "title": "Xlim",
            "default": [
              -5,
              5
            ],
            "maxItems": 2,
            "minItems": 2,
            "prefixItems": [
              {
                "type": "integer"
              },
              {
                "type": "integer"
              }
            ]
          },
          "ylim": {
            "type": "array",
            "title": "Ylim",
            "default": [
              -5,
              5
            ],
            "maxItems": 2,
            "minItems": 2,
            "prefixItems": [
              {
                "type": "integer"
              },
              {
                "type": "integer"
              }
            ]
          },
          "expr_str": {
            "type": "string",
            "title": "Expr Str"
          }
        }
      }
    }
  ],
  "_sync": {
    "fetched_at": "2026-01-04T13:08:34.096927+00:00",
    "source": "smithery"
  }
}