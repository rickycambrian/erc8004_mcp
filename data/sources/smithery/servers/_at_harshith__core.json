{
  "qualifiedName": "@harshith/core",
  "displayName": "core",
  "description": "Recall past conversations and user preferences with searchable long\u2011term memory. Organize work into spaces and quickly load rich project context. Act across connected services like GitHub, Linear, and Slack with discoverable integration actions.",
  "iconUrl": null,
  "remote": true,
  "deploymentUrl": "https://server.smithery.ai/@harshith/core",
  "connections": [
    {
      "type": "http",
      "deploymentUrl": "https://server.smithery.ai/@harshith/core/mcp",
      "configSchema": {}
    }
  ],
  "security": null,
  "tools": [
    {
      "name": "memory_ingest",
      "description": "Store conversation in memory for future reference. USE THIS TOOL: At the END of every conversation after fully answering the user. WHAT TO STORE: 1) User's question or request, 2) Your solution or explanation, 3) Important decisions made, 4) Key insights discovered. HOW TO USE: Put the entire conversation summary in the 'message' field. IMPORTANT: You MUST provide a sessionId - if you don't have one, call initialize_conversation_session tool FIRST to obtain it at the start of the conversation, then use that SAME sessionId for all memory_ingest calls. Optionally add spaceIds array to organize by project. Returns: Success confirmation with storage ID.",
      "inputSchema": {
        "type": "object",
        "required": [
          "message",
          "sessionId"
        ],
        "properties": {
          "message": {
            "type": "string",
            "description": "The conversation text to store. Include both what the user asked and what you answered. Keep it concise but complete."
          },
          "spaceIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional: Array of space UUIDs (from memory_get_spaces). Add this to organize the memory by project. Example: If discussing 'core' project, include the 'core' space ID. Leave empty to store in general memory."
          },
          "sessionId": {
            "type": "string",
            "description": "IMPORTANT: Session ID (UUID) is required to track the conversation session. If you don't have a sessionId in your context, you MUST call the initialize_conversation_session tool first to obtain one before calling memory_ingest."
          }
        }
      }
    },
    {
      "name": "memory_search",
      "description": "Search stored memories for past conversations, user preferences, project context, and decisions. USE THIS TOOL: 1) At start of every conversation to find related context, 2) When user mentions past work or projects, 3) Before answering questions that might have previous context. HOW TO USE: Write a simple query describing what to find (e.g., 'user code preferences', 'authentication bugs', 'API setup steps'). Returns: Markdown-formatted context optimized for LLM consumption, including session compacts, episodes, and key facts with temporal metadata.",
      "inputSchema": {
        "type": "object",
        "required": [
          "query"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query optimized for knowledge graph retrieval. Choose the right query structure based on your search intent:\n\n1. **Entity-Centric Queries** (Best for graph search):\n   - \u2705 GOOD: \"User's preferences for code style and formatting\"\n   - \u2705 GOOD: \"Project authentication implementation decisions\"\n   - \u274c BAD: \"user code style\"\n   - Format: [Person/Project] + [relationship/attribute] + [context]\n\n2. **Multi-Entity Relationship Queries** (Excellent for episode graph):\n   - \u2705 GOOD: \"User and team discussions about API design patterns\"\n   - \u2705 GOOD: \"relationship between database schema and performance optimization\"\n   - \u274c BAD: \"user team api design\"\n   - Format: [Entity1] + [relationship type] + [Entity2] + [context]\n\n3. **Semantic Question Queries** (Good for vector search):\n   - \u2705 GOOD: \"What causes authentication errors in production? What are the security requirements?\"\n   - \u2705 GOOD: \"How does caching improve API response times compared to direct database queries?\"\n   - \u274c BAD: \"auth errors production\"\n   - Format: Complete natural questions with full context\n\n4. **Concept Exploration Queries** (Good for BFS traversal):\n   - \u2705 GOOD: \"concepts and ideas related to database indexing and query optimization\"\n   - \u2705 GOOD: \"topics connected to user authentication and session management\"\n   - \u274c BAD: \"database indexing concepts\"\n   - Format: [concept] + related/connected + [domain/context]\n\nAvoid keyword soup queries - use complete phrases with proper context for best results."
          },
          "sortBy": {
            "enum": [
              "relevance",
              "recency"
            ],
            "type": "string",
            "description": "Optional: Sort results by 'relevance' (default, best semantic matches ranked by rerank score) or 'recency' (chronological order, newest first). Use 'relevance' for conceptual questions and 'recency' for timeline/recent activity queries."
          },
          "endTime": {
            "type": "string",
            "description": "Optional: ISO timestamp (like '2024-12-31T23:59:59Z'). Only find memories created BEFORE this time. USE WHEN: User asks for historical queries like 'before X date', 'until last month', or specific time ranges. EXAMPLES: - 'work from last month' \u2192 set startTime to first day of last month, endTime to last day of last month; - 'before March' \u2192 set endTime to '2025-03-01T00:00:00Z'; - 'between Jan and Mar' \u2192 set startTime='2025-01-01T00:00:00Z', endTime='2025-03-31T23:59:59Z'. IMPORTANT: Use with startTime to define time windows. Always use ISO format with timezone (Z for UTC)."
          },
          "validAt": {
            "type": "string",
            "description": "Optional: ISO timestamp (like '2024-01-15T10:30:00Z'). Get facts that were true at this specific time. Leave empty for current facts."
          },
          "spaceIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Optional: Array of space UUIDs to search within. Leave empty to search all spaces."
          },
          "startTime": {
            "type": "string",
            "description": "Optional: ISO timestamp (like '2024-01-01T00:00:00Z'). Only find memories created AFTER this time. USE WHEN: User asks for 'recent', 'this week', 'last month', 'since X date' queries. EXAMPLES: - 'recent work' \u2192 set startTime to 7 days ago; - 'this week' \u2192 set startTime to start of current week; - 'since January' \u2192 set startTime to '2025-01-01T00:00:00Z'. IMPORTANT: Calculate relative dates from today's date (see system context). Combine with sortBy='recency' for chronological timeline."
          }
        }
      }
    },
    {
      "name": "memory_get_spaces",
      "description": "List all available memory spaces (project contexts). USE THIS TOOL: To see what spaces exist before searching or storing memories. Each space organizes memories by topic (e.g., 'Profile' for user info, 'GitHub' for GitHub work, project names for project-specific context). Returns: Array of spaces with id, name, and description.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "all": {
            "type": "boolean",
            "description": "Set to true to get all spaces including system spaces. Leave empty for user spaces only."
          }
        }
      }
    },
    {
      "name": "memory_about_user",
      "description": "Get user's profile information (background, preferences, work, interests). USE THIS TOOL: At the start of conversations to understand who you're helping. This provides context about the user's technical preferences, work style, and personal details. Returns: User profile summary as text.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "profile": {
            "type": "boolean",
            "description": "Set to true to get full profile. Leave empty for default profile view."
          }
        }
      }
    },
    {
      "name": "memory_get_space",
      "description": "Get detailed information about a specific space including its full summary. USE THIS TOOL: When working on a project to get comprehensive context about that project. The summary contains consolidated knowledge about the space topic. HOW TO USE: Provide either spaceName (like 'core', 'GitHub', 'Profile') OR spaceId (UUID). Returns: Space details with full summary, description, and metadata.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "spaceId": {
            "type": "string",
            "description": "UUID of the space (use this if you have the ID from memory_get_spaces)"
          },
          "spaceName": {
            "type": "string",
            "description": "Name of the space (easier option). Examples: 'core', 'Profile', 'GitHub', 'Health'"
          }
        }
      }
    },
    {
      "name": "initialize_conversation_session",
      "description": "Initialize a session for this conversation. MUST be called FIRST at the start of every conversation before any memory_ingest calls. This generates a unique UUID that tracks the entire conversation session. IMPORTANT: One conversation = one session. Call this tool once at the beginning, store the returned sessionId, and use that SAME sessionId for ALL memory_ingest operations throughout this conversation. DO NOT create custom session IDs. Returns: A UUID string to use as sessionId for all subsequent memory operations.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "new": {
            "type": "boolean",
            "description": "Set to true to initialize a new conversation session."
          }
        }
      }
    },
    {
      "name": "get_integrations",
      "description": "List all connected integrations (GitHub, Linear, Slack, etc.). USE THIS TOOL: Before using integration actions to see what's available. WORKFLOW: 1) Call this to see available integrations, 2) Call get_integration_actions with a slug to see what you can do, 3) Call execute_integration_action to do it. Returns: Array with slug, name, accountId, and hasMcp for each integration.",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "get_integration_actions",
      "description": "Get list of actions available for a specific integration. USE THIS TOOL: After get_integrations to see what operations you can perform. For example, GitHub integration has actions like 'get_pr', 'get_issues', 'create_issue'. HOW TO USE: Provide the integrationSlug from get_integrations (like 'github', 'linear', 'slack'). Returns: Array of actions with name, description, and inputSchema for each.",
      "inputSchema": {
        "type": "object",
        "required": [
          "integrationSlug"
        ],
        "properties": {
          "integrationSlug": {
            "type": "string",
            "description": "Slug from get_integrations. Examples: 'github', 'linear', 'slack'"
          }
        }
      }
    },
    {
      "name": "execute_integration_action",
      "description": "Execute an action on an integration (fetch GitHub PR, create Linear issue, send Slack message, etc.). USE THIS TOOL: After using get_integration_actions to see available actions. HOW TO USE: 1) Set integrationSlug (like 'github'), 2) Set action name (like 'get_pr'), 3) Set arguments object with required parameters from the action's inputSchema. Returns: Result of the action execution.",
      "inputSchema": {
        "type": "object",
        "required": [
          "integrationSlug",
          "action"
        ],
        "properties": {
          "action": {
            "type": "string",
            "description": "Action name from get_integration_actions. Examples: 'get_pr', 'get_issues', 'create_issue'"
          },
          "arguments": {
            "type": "object",
            "description": "Parameters for the action. Check the action's inputSchema from get_integration_actions to see what's required."
          },
          "integrationSlug": {
            "type": "string",
            "description": "Slug from get_integrations. Examples: 'github', 'linear', 'slack'"
          }
        }
      }
    }
  ],
  "_sync": {
    "fetched_at": "2026-01-04T13:26:13.699751+00:00",
    "source": "smithery"
  }
}