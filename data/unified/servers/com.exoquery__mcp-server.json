{
  "id": "com.exoquery/mcp-server",
  "name": "com.exoquery/mcp-server",
  "display_name": "com.exoquery/mcp-server",
  "version": "1.0.0",
  "description": "Kotlin compile-time SQL library. Docs, code validation, and SQLite execution tools.",
  "icon_url": null,
  "repository_url": null,
  "status": "active",
  "published_at": "2025-12-19T04:31:27.91887Z",
  "tools": [
    {
      "name": "getExoQueryDocs",
      "title": "getExoQueryDocs",
      "description": "\nAccess comprehensive ExoQuery documentation organized by topic and category.\n\nExoQuery is a Language Integrated Query library for Kotlin Multiplatform that translates Kotlin DSL expressions into SQL at compile time. This resource provides access to the complete documentation covering all aspects of the library.\n\nAVAILABLE DOCUMENTATION CATEGORIES:\n\n1. **Getting Started**\n   - Introduction: What ExoQuery is and why it exists\n   - Installation: Project setup and dependencies\n   - Quick Start: First query in minutes\n\n2. **Core Concepts**\n   - SQL Blocks: The sql { } construct and query building\n   - Parameters: Safe runtime data handling\n   - Composing Queries: Functional query composition\n\n3. **Query Operations**\n   - Basic Operations: Map, filter, and transformations\n   - Joins: Inner, left, and implicit joins\n   - Grouping: GROUP BY and HAVING clauses\n   - Sorting: ORDER BY operations\n   - Subqueries: Correlated and nested queries\n   - Window Functions: Advanced analytics\n\n4. **Actions**\n   - Insert: INSERT with returning and conflict handling\n   - Update: UPDATE operations with setParams\n   - Delete: DELETE with returning\n   - Batch Operations: Bulk inserts and updates\n\n5. **Advanced Features**\n   - SQL Fragment Functions: Reusable SQL components with @SqlFragment\n   - Dynamic Queries: Runtime query generation with @SqlDynamic\n   - Free Blocks: Custom SQL and user-defined functions\n   - Transactions: Transaction support patterns\n   - Polymorphic Queries: Interfaces, sealed classes, higher-order functions\n   - Local Variables: Variables within SQL blocks\n\n6. **Data Handling**\n   - Serialization: kotlinx.serialization integration\n   - Custom Type Encoding: Custom encoders and decoders\n   - JSON Columns: JSON and JSONB support (PostgreSQL)\n   - Column Naming: @SerialName and @ExoEntity annotations\n   - Nested Datatypes: Complex data structures\n   - Kotlinx Integration: JSON and other serialization formats\n\n7. **Schema-First Development**\n   - Entity Generation: Compile-time code generation from database schema\n   - AI-Enhanced Entities: Using LLMs to generate cleaner entity code\n\n8. **Reference**\n   - SQL Functions: Available string, math, and date functions\n   - API Reference: Core types and function signatures\n\nHOW TO USE THIS RESOURCE:\n\nThe resource URI follows the pattern:\n  exoquery://docs/{file-path}\n\nWhere {file-path} is the relative path from the docs root, e.g.:\n  - exoquery://docs/01-getting-started/01-introduction.md\n  - exoquery://docs/03-query-operations/02-joins.md\n  - exoquery://docs/05-advanced-features/01-sql-fragments.md\n\nTo discover available documents, use the MCP resources/list endpoint which will return all available documentation files with their titles, descriptions, and categories.\n\nEach document includes:\n- Title and description\n- Category classification\n- Complete markdown content with code examples\n- Cross-references to related topics\n\nWHEN TO USE:\n- User asks about ExoQuery syntax, features, or capabilities\n- User needs examples of specific query patterns\n- User encounters errors and needs to verify correct usage\n- User wants to understand advanced features or best practices\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "filePath": {
            "type": "string",
            "description": "\nThe documentation file path to retrieve.\n\nFormat: Relative path from docs root (e.g., \"01-getting-started/01-introduction.md\")\n\nThe full URI is: exoquery://docs/{file-path}\n\nTo find available file paths, use the MCP resources/list endpoint which returns metadata for all documentation files including their paths, titles, categories, and descriptions.\n\nCommon paths:\n- Getting Started: 01-getting-started/01-introduction.md, 01-getting-started/02-installation.md, 01-getting-started/03-quick-start.md\n- Core Concepts: 02-core-concepts/01-sql-blocks.md, 02-core-concepts/02-parameters.md, 02-core-concepts/03-composing-queries.md\n- Query Operations: 03-query-operations/01-basic-operations.md, 03-query-operations/02-joins.md, 03-query-operations/03-grouping.md\n- Actions: 04-actions/01-insert.md, 04-actions/02-update.md, 04-actions/03-delete.md\n- Advanced: 05-advanced-features/01-sql-fragments.md, 05-advanced-features/02-dynamic-queries.md\n- Data Handling: 06-data-handling/03-json-columns.md, 06-data-handling/04-column-naming.md\n"
          }
        },
        "required": [
          "filePath"
        ]
      },
      "annotations": {
        "title": "",
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": false,
        "openWorldHint": true
      }
    },
    {
      "name": "getExoQueryDocsMulti",
      "title": "getExoQueryDocsMulti",
      "description": "\nAccess multiple ExoQuery documentation sections simultaneously.\n\nThis tool is similar to the single-document retrieval tool but allows fetching multiple documentation files in a single request. This is particularly useful when you need to gather information from several related topics at once.\n\nExoQuery is a Language Integrated Query library for Kotlin Multiplatform that translates Kotlin DSL expressions into SQL at compile time. This resource provides access to the complete documentation covering all aspects of the library.\n\nHOW TO USE THIS RESOURCE:\n\nProvide a list of file paths, where each path is the relative path from the docs root, e.g.:\n  - 01-getting-started/01-introduction.md\n  - 03-query-operations/02-joins.md\n  - 05-advanced-features/01-sql-fragments.md\n\nTo discover available documents, use the MCP resources/list endpoint which will return all available documentation files with their titles, descriptions, and categories.\n\nEach returned document includes:\n- Title and description\n- Category classification\n- Complete markdown content with code examples\n- Cross-references to related topics\n\nWHEN TO USE:\n- User asks about multiple ExoQuery topics that require information from different sections\n- User needs to compare or understand relationships between different features\n- User wants to get comprehensive information across multiple categories\n- More efficient than making multiple single-document requests\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "filePaths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "\nA list of documentation file paths to retrieve.\n\nFormat: List of relative paths from docs root (e.g., [\"01-getting-started/01-introduction.md\", \"03-query-operations/02-joins.md\"])\n\nEach path follows the pattern used in single-document retrieval: {category-folder}/{file-name}.md\n\nTo find available file paths, use the MCP resources/list endpoint which returns metadata for all documentation files including their paths, titles, categories, and descriptions.\n\nCommon paths:\n- Getting Started: 01-getting-started/01-introduction.md, 01-getting-started/02-installation.md, 01-getting-started/03-quick-start.md\n- Core Concepts: 02-core-concepts/01-sql-blocks.md, 02-core-concepts/02-parameters.md, 02-core-concepts/03-composing-queries.md\n- Query Operations: 03-query-operations/01-basic-operations.md, 03-query-operations/02-joins.md, 03-query-operations/03-grouping.md\n- Actions: 04-actions/01-insert.md, 04-actions/02-update.md, 04-actions/03-delete.md\n- Advanced: 05-advanced-features/01-sql-fragments.md, 05-advanced-features/02-dynamic-queries.md\n- Data Handling: 06-data-handling/03-json-columns.md, 06-data-handling/04-column-naming.md\n"
          }
        },
        "required": [
          "filePaths"
        ]
      },
      "annotations": {
        "title": "",
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": false,
        "openWorldHint": true
      }
    },
    {
      "name": "listExoQueryDocs",
      "title": "listExoQueryDocs",
      "description": "Lists all available ExoQuery documentation resources with their metadata",
      "inputSchema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "annotations": {
        "title": "",
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": false,
        "openWorldHint": true
      }
    },
    {
      "name": "validateAndRunExoquery",
      "title": "validateAndRunExoquery",
      "description": "\nCompile ExoQuery Kotlin code and EXECUTE it against an Sqlite database with provided schema.\nExoQuery is a compile-time SQL query builder that translates Kotlin DSL expressions into SQL.\n\nWHEN TO USE: When you need to verify ExoQuery produces correct results against actual data.\n\nINPUT REQUIREMENTS:\n- Complete Kotlin code (same requirements as validateExoquery)\n- SQL schema with CREATE TABLE and INSERT statements for test data\n- Data classes MUST exactly match the schema table structure\n- Column names in data classes must match schema (use @SerialName for snake_case columns)\n- Must include or or more .runSample() calls in main() to trigger SQL generation and execution\n  (note that .runSample() is NOT or real production use, use .runOn(database) instead)\n  \n\nOUTPUT FORMAT:\n\nReturns one or more JSON objects, each on its own line. Each object can be:\n\n1. SQL with output (query executed successfully):\n   {\"sql\": \"SELECT u.name FROM \\\"User\\\" u\", \"output\": \"[(name=Alice), (name=Bob)]\"}\n\n2. Output only (e.g., print statements, intermediate results):\n   {\"output\": \"Before: [(id=1, title=Ion Blend Beans)]\"}\n\n3. Error output (runtime errors, exceptions):\n   {\"outputErr\": \"java.sql.SQLException: Table \\\"USERS\\\" not found\"}\n\nMultiple results appear when code has multiple queries or print statements:\n\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25)]\"}\n{\"output\": \"Before:\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"Rows affected: 1\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25), (id=2, title=Luna Fuel Flask, unit_price=89.50, in_stock=6)]\"}\n\nCompilation errors return the same format as validateExoquery:\n{\n  \"errors\": {\n    \"File.kt\": [\n      {\n        \"interval\": {\"start\": {\"line\": 12, \"ch\": 10}, \"end\": {\"line\": 12, \"ch\": 15}},\n        \"message\": \"Type mismatch: inferred type is String but Int was expected\",\n        \"severity\": \"ERROR\",\n        \"className\": \"ERROR\"\n      }\n    ]\n  }\n}\n\nRuntime Errors can have the following format:\n{\n  \"errors\" : {\n    \"File.kt\" : [ ]\n  },\n  \"exception\" : {\n    \"message\" : \"[SQLITE_ERROR] SQL error or missing database (no such table: User)\",\n    \"fullName\" : \"org.sqlite.SQLiteException\",\n    \"stackTrace\" : [ {\n      \"className\" : \"org.sqlite.core.DB\",\n      \"methodName\" : \"newSQLException\",\n      \"fileName\" : \"DB.java\",\n      \"lineNumber\" : 1179\n    }, ...]\n  },\n  \"text\" : \"<outStream><outputObject>\\n{\\\"sql\\\": \\\"SELECT x.id, x.name, x.age FROM User x\\\"}\\n</outputObject>\\n</outStream>\"\n}\nIf there was a SQL query generated before the error, it will appear in the \"text\" field output stream.\n\n\nEXAMPLE INPUT CODE:\n```kotlin\nimport io.exoquery.*\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.SerialName\n\n@Serializable\ndata class User(val id: Int, val name: String, val age: Int)\n\n@Serializable\ndata class Order(val id: Int, @SerialName(\"user_id\") val userId: Int, val total: Int)\n\nval userOrders = sql.select {\n    val u = from(Table<User>())\n    val o = join(Table<Order>()) { o -> o.userId == u.id }\n    Triple(u.name, o.total, u.age)\n}\n\nfun main() = userOrders.buildPrettyFor.Sqlite().runSample()\n```\n\nEXAMPLE INPUT SCHEMA:\n```sql\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nCREATE TABLE \"Order\" (id INT, user_id INT, total INT);\n\nINSERT INTO \"User\" (id, name, age) VALUES\n  (1, 'Alice', 30),\n  (2, 'Bob', 25);\n\nINSERT INTO \"Order\" (id, user_id, total) VALUES\n  (1, 1, 100),\n  (2, 1, 200),\n  (3, 2, 150);\n```\n\nEXAMPLE SUCCESS OUTPUT:\n{\"sql\": \"SELECT u.name AS first, o.total AS second, u.age AS third FROM \\\"User\\\" u INNER JOIN \\\"Order\\\" o ON o.user_id = u.id\", \"output\": \"[(first=Alice, second=100, third=30), (first=Alice, second=200, third=30), (first=Bob, second=150, third=25)]\"}\n\nEXAMPLE WITH MULTIPLE OPERATIONS (insert with before/after check):\n{\"output\": \"Before:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans)]\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans), (id=2, title=Luna Fuel Flask)]\"}\n\nEXAMPLE RUNTIME ERROR (if a user divided by zero):\n{\"outputErr\": \"Exception in thread \"main\" java.lang.ArithmeticException: / by zero\"}\n\nKEY PATTERNS:\n\n(See validateExoquery for complete pattern reference)\n\nSummary of most common patterns:\n- Filter: sql { Table<T>().filter { x -> x.field == value } }\n- Select: sql.select { val x = from(Table<T>()); where { ... }; x }\n- Join: sql.select { val a = from(Table<A>()); val b = join(Table<B>()) { b -> b.aId == a.id }; Pair(a, b) }\n- Left join: joinLeft(Table<T>()) { ... } returns nullable\n- Insert: sql { insert<T> { setParams(obj).excluding(id) } }\n- Update: sql { update<T>().set { it.field to value }.where { it.id == x } }\n- Delete: sql { delete<T>().where { it.id == x } }\n\nSCHEMA RULES:\n- Table names should match data class names (case-sensitive, use quotes for exact match)\n- Column names must match @SerialName values or property names\n- Include realistic test data to verify query logic\n- Sqlite database syntax (mostly compatible with standard SQL)\n\nCOMMON PATTERNS:\n- JSON columns: Use VARCHAR for storage, @SqlJsonValue on the nested data class\n- Auto-increment IDs: Use INTEGER PRIMARY KEY\n- Nullable columns: Use Type? in Kotlin, allow NULL in schema\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "\nComplete ExoQuery Kotlin code to compile and execute.\n\nMust include:\n1. Imports (minimum: io.exoquery.*, kotlinx.serialization.Serializable)\n2. @Serializable data classes that EXACTLY match your schema tables\n3. The query expression\n4. A main() function ending with .buildFor.<Dialect>().runSample()\n    This function MUST be present to trigger SQL generation and execution.\n\nUse @SerialName(\"column_name\") when Kotlin property names differ from SQL column names.\nUse @Contextual for BigDecimal fields.\nUse @SqlJsonValue on data classes that represent JSON column values.\n\nMultiple queries in main() will produce multiple output JSON objects.\n"
          },
          "schema": {
            "type": "string",
            "description": "\nSQL schema to initialize the Sqlite test database.\n\nMust include:\n1. CREATE TABLE statements for all tables referenced in the query\n2. INSERT statements with test data to verify query behavior\n\nTable and column names must exactly match the data classes in the code.\nUse double quotes around table names to preserve case: CREATE TABLE \"User\" (...)\n\nCommon error: Table \"USER\" not found, means you wrote CREATE TABLE User but queried \"User\". \nAlways quote table names in schema to match ExoQuery's generated SQL.\n\nExample:\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nINSERT INTO \"User\" VALUES (1, 'Alice', 30), (2, 'Bob', 25);\n"
          }
        },
        "required": [
          "code",
          "schema"
        ]
      },
      "annotations": {
        "title": "",
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": false,
        "openWorldHint": true
      }
    },
    {
      "name": "validateExoquery",
      "title": "validateExoquery",
      "description": "\nCompile ExoQuery Kotlin code and EXECUTE it against an Sqlite database with provided schema.\nExoQuery is a compile-time SQL query builder that translates Kotlin DSL expressions into SQL.\n\nWHEN TO USE: When you need to verify ExoQuery produces correct results against actual data.\n\nINPUT REQUIREMENTS:\n- Complete Kotlin code (same requirements as validateExoquery)\n- SQL schema with CREATE TABLE and INSERT statements for test data\n- Data classes MUST exactly match the schema table structure\n- Column names in data classes must match schema (use @SerialName for snake_case columns)\n- Must include or or more .runSample() calls in main() to trigger SQL generation and execution\n  (note that .runSample() is NOT or real production use, use .runOn(database) instead)\n  \n\nOUTPUT FORMAT:\n\nReturns one or more JSON objects, each on its own line. Each object can be:\n\n1. SQL with output (query executed successfully):\n   {\"sql\": \"SELECT u.name FROM \\\"User\\\" u\", \"output\": \"[(name=Alice), (name=Bob)]\"}\n\n2. Output only (e.g., print statements, intermediate results):\n   {\"output\": \"Before: [(id=1, title=Ion Blend Beans)]\"}\n\n3. Error output (runtime errors, exceptions):\n   {\"outputErr\": \"java.sql.SQLException: Table \\\"USERS\\\" not found\"}\n\nMultiple results appear when code has multiple queries or print statements:\n\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25)]\"}\n{\"output\": \"Before:\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"Rows affected: 1\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans, unit_price=32.00, in_stock=25), (id=2, title=Luna Fuel Flask, unit_price=89.50, in_stock=6)]\"}\n\nCompilation errors return the same format as validateExoquery:\n{\n  \"errors\": {\n    \"File.kt\": [\n      {\n        \"interval\": {\"start\": {\"line\": 12, \"ch\": 10}, \"end\": {\"line\": 12, \"ch\": 15}},\n        \"message\": \"Type mismatch: inferred type is String but Int was expected\",\n        \"severity\": \"ERROR\",\n        \"className\": \"ERROR\"\n      }\n    ]\n  }\n}\n\nRuntime Errors can have the following format:\n{\n  \"errors\" : {\n    \"File.kt\" : [ ]\n  },\n  \"exception\" : {\n    \"message\" : \"[SQLITE_ERROR] SQL error or missing database (no such table: User)\",\n    \"fullName\" : \"org.sqlite.SQLiteException\",\n    \"stackTrace\" : [ {\n      \"className\" : \"org.sqlite.core.DB\",\n      \"methodName\" : \"newSQLException\",\n      \"fileName\" : \"DB.java\",\n      \"lineNumber\" : 1179\n    }, ...]\n  },\n  \"text\" : \"<outStream><outputObject>\\n{\\\"sql\\\": \\\"SELECT x.id, x.name, x.age FROM User x\\\"}\\n</outputObject>\\n</outStream>\"\n}\nIf there was a SQL query generated before the error, it will appear in the \"text\" field output stream.\n\n\nEXAMPLE INPUT CODE:\n```kotlin\nimport io.exoquery.*\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.SerialName\n\n@Serializable\ndata class User(val id: Int, val name: String, val age: Int)\n\n@Serializable\ndata class Order(val id: Int, @SerialName(\"user_id\") val userId: Int, val total: Int)\n\nval userOrders = sql.select {\n    val u = from(Table<User>())\n    val o = join(Table<Order>()) { o -> o.userId == u.id }\n    Triple(u.name, o.total, u.age)\n}\n\nfun main() = userOrders.buildPrettyFor.Sqlite().runSample()\n```\n\nEXAMPLE INPUT SCHEMA:\n```sql\nCREATE TABLE \"User\" (id INT, name VARCHAR(100), age INT);\nCREATE TABLE \"Order\" (id INT, user_id INT, total INT);\n\nINSERT INTO \"User\" (id, name, age) VALUES\n  (1, 'Alice', 30),\n  (2, 'Bob', 25);\n\nINSERT INTO \"Order\" (id, user_id, total) VALUES\n  (1, 1, 100),\n  (2, 1, 200),\n  (3, 2, 150);\n```\n\nEXAMPLE SUCCESS OUTPUT:\n{\"sql\": \"SELECT u.name AS first, o.total AS second, u.age AS third FROM \\\"User\\\" u INNER JOIN \\\"Order\\\" o ON o.user_id = u.id\", \"output\": \"[(first=Alice, second=100, third=30), (first=Alice, second=200, third=30), (first=Bob, second=150, third=25)]\"}\n\nEXAMPLE WITH MULTIPLE OPERATIONS (insert with before/after check):\n{\"output\": \"Before:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans)]\"}\n{\"sql\": \"INSERT INTO \\\"InventoryItem\\\" (title, unit_price, in_stock) VALUES (?, ?, ?)\", \"output\": \"\"}\n{\"output\": \"After:\"}\n{\"sql\": \"SELECT * FROM \\\"InventoryItem\\\"\", \"output\": \"[(id=1, title=Ion Blend Beans), (id=2, title=Luna Fuel Flask)]\"}\n\nEXAMPLE RUNTIME ERROR (if a user divided by zero):\n{\"outputErr\": \"Exception in thread \"main\" java.lang.ArithmeticException: / by zero\"}\n\nKEY PATTERNS:\n\n(See validateExoquery for complete pattern reference)\n\nSummary of most common patterns:\n- Filter: sql { Table<T>().filter { x -> x.field == value } }\n- Select: sql.select { val x = from(Table<T>()); where { ... }; x }\n- Join: sql.select { val a = from(Table<A>()); val b = join(Table<B>()) { b -> b.aId == a.id }; Pair(a, b) }\n- Left join: joinLeft(Table<T>()) { ... } returns nullable\n- Insert: sql { insert<T> { setParams(obj).excluding(id) } }\n- Update: sql { update<T>().set { it.field to value }.where { it.id == x } }\n- Delete: sql { delete<T>().where { it.id == x } }\n\nSCHEMA RULES:\n- Table names should match data class names (case-sensitive, use quotes for exact match)\n- Column names must match @SerialName values or property names\n- Include realistic test data to verify query logic\n- Sqlite database syntax (mostly compatible with standard SQL)\n\nCOMMON PATTERNS:\n- JSON columns: Use VARCHAR for storage, @SqlJsonValue on the nested data class\n- Auto-increment IDs: Use INTEGER PRIMARY KEY\n- Nullable columns: Use Type? in Kotlin, allow NULL in schema\n",
      "inputSchema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "\nComplete ExoQuery Kotlin code to compile.\n\nMust include:\n1. Imports (minimum: io.exoquery.*, kotlinx.serialization.Serializable)\n2. @Serializable data classes matching your query entities\n3. The query expression using sql { ... } or sql.select { ... }\n4. A main() function ending with .buildFor.<Dialect>().runSample() or .buildPrettyFor.<Dialect>().runSample()\n   This function MUST be present to trigger SQL generation.\n\nThe runSample() function triggers SQL generation but does NOT execute the query for validateExoquery.\n(Note that this is NOT for production ExoQuery usage. For that you use `.runOn(database)`.)\n\nDialect is part of the code (e.g., .buildFor.Postgres()), NOT a separate parameter.\n\nIf compilation fails, check the error interval positions to locate the exact issue in your code.\n"
          }
        },
        "required": [
          "code"
        ]
      },
      "annotations": {
        "title": "",
        "readOnlyHint": false,
        "destructiveHint": true,
        "idempotentHint": false,
        "openWorldHint": true
      }
    }
  ],
  "tool_count": 5,
  "prompts": [],
  "resources": [],
  "remote_endpoint": "https://backend.exoquery.com/mcp",
  "packages": [],
  "sources": [
    "anthropic"
  ],
  "primary_source": "anthropic",
  "is_latest": true,
  "verified": false,
  "use_count": 0,
  "has_remote": true,
  "has_tools": true,
  "tool_names": [
    "getExoQueryDocs",
    "getExoQueryDocsMulti",
    "listExoQueryDocs",
    "validateAndRunExoquery",
    "validateExoquery"
  ]
}