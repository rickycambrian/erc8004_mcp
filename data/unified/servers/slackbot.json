{
  "id": "slackbot",
  "name": "slackbot",
  "display_name": "Slackbot",
  "version": null,
  "description": "Slackbot automates responses and reminders within Slack, assisting with tasks like onboarding, FAQs, and notifications to streamline team productivity",
  "icon_url": "https://logos.composio.dev/api/slackbot",
  "repository_url": null,
  "status": "active",
  "published_at": null,
  "tools": [
    {
      "name": "SLACKBOT_ACTIVATE_OR_MODIFY_DO_NOT_DISTURB_DURATION",
      "description": "DEPRECATED: Turns on Do Not Disturb mode for the current user, or changes its duration. Use `set_dnd_duration` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SetDndDurationRequest",
        "required": [
          "num_minutes"
        ],
        "properties": {
          "num_minutes": {
            "type": "string",
            "title": "Num Minutes",
            "examples": [
              "60"
            ],
            "description": "Number of minutes, from now, to snooze until."
          }
        },
        "description": "Request schema for `SetDndDuration`"
      }
    },
    {
      "name": "SLACKBOT_ADD_A_CUSTOM_EMOJI_TO_A_TEAM",
      "description": "DEPRECATED: Adds a custom emoji to a Slack workspace given a unique name and an image URL. Use `add_emoji` instead.",
      "inputSchema": {
        "type": "object",
        "title": "AddEmojiRequest",
        "required": [
          "name",
          "token",
          "url"
        ],
        "properties": {
          "url": {
            "type": "string",
            "title": "Url",
            "examples": [
              "https://example.com/emoji/partyparrot.gif",
              "https://cdn.example.com/images/approved_stamp.png"
            ],
            "description": "The URL of the image file to be used as the custom emoji. The image should be accessible via HTTP/HTTPS and meet Slack's emoji requirements (e.g., size, format). Supported formats typically include PNG, GIF, and JPEG."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "partyparrot",
              "approved_stamp",
              "team_logo_small"
            ],
            "description": "The desired name for the new custom emoji. This name will be used to invoke the emoji (e.g., if name is 'partyparrot', it's used as ':partyparrot:'). Colons around the name are not required when providing this field."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token used to authorize the request to add a custom emoji to the Slack workspace."
          }
        },
        "description": "Request schema for `AddEmoji`"
      }
    },
    {
      "name": "SLACKBOT_ADD_AN_EMOJI_ALIAS_IN_SLACK",
      "description": "Adds an alias for an existing custom emoji in a Slack Enterprise Grid organization.",
      "inputSchema": {
        "type": "object",
        "title": "AddAnEmojiAliasInSlackRequest",
        "required": [
          "alias_for",
          "name",
          "token"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "parrot_alias",
              ":approved_alias:"
            ],
            "description": "The new alias to be created for the emoji specified in `alias_for` (e.g., `new_emoji_alias`). Colons around the name (e.g., `:my_alias:`) are optional and will be automatically trimmed, along with any leading/trailing whitespace."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token. Requires the `admin.teams:write` scope."
          },
          "alias_for": {
            "type": "string",
            "title": "Alias For",
            "examples": [
              "party_parrot",
              "approved_stamp"
            ],
            "description": "The canonical name of the existing custom emoji (e.g., `original_emoji`)."
          }
        },
        "description": "Request schema for `AddAnEmojiAliasInSlack`"
      }
    },
    {
      "name": "SLACKBOT_ADD_A_REMOTE_FILE_FROM_A_SERVICE",
      "description": "Adds a reference to an external file (e.g., Google Drive, Dropbox) to Slack for discovery and sharing, requiring a unique `external_id` and an `external_url` accessible by Slack.",
      "inputSchema": {
        "type": "object",
        "title": "AddARemoteFileFromAServiceRequest",
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Project Proposal Q3.docx",
              "Client Onboarding Checklist.pdf"
            ],
            "description": "Title of the remote file to be displayed in Slack."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "examples": [
              "xoxp-123456789012-123456789012-1234567890123-abcdefghijklmnopqrstuvwxyz123456"
            ],
            "description": "Slack authentication token, required to authorize adding the remote file."
          },
          "filetype": {
            "type": "string",
            "title": "Filetype",
            "examples": [
              "pdf",
              "docx",
              "gdoc",
              "png",
              "txt",
              "gsheet"
            ],
            "description": "File type (e.g., 'pdf', 'docx', 'png') to help Slack display appropriate icons or previews."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "file-abc-123-xyz-789",
              "guid-document-42"
            ],
            "description": "Unique identifier for the file, defined by the calling application, used for future API references (e.g., updating, deleting)."
          },
          "external_url": {
            "type": "string",
            "title": "External Url",
            "examples": [
              "https://example.com/path/to/your/file.pdf",
              "https://your-service.com/files/unique-id-123"
            ],
            "description": "Publicly accessible or permissioned URL of the remote file, used by Slack to access its content or metadata."
          },
          "preview_image": {
            "type": "string",
            "title": "Preview Image",
            "examples": [
              "(base64 encoded PNG data of a chart)",
              "(base64 encoded JPEG data of a document cover)"
            ],
            "description": "Base64-encoded image (e.g., PNG, JPEG) used as the file's preview in Slack."
          },
          "indexable_file_contents": {
            "type": "string",
            "title": "Indexable File Contents",
            "examples": [
              "This document contains project plans for Q4, focusing on market expansion and new product development.",
              "Meeting notes from Q1 review: Key discussion points included budget allocation, resource management, and upcoming deadlines."
            ],
            "description": "Plain text content of the file, indexed by Slack for search."
          }
        },
        "description": "Request schema for adding a remote file to Slack."
      }
    },
    {
      "name": "SLACKBOT_ADD_A_STAR_TO_AN_ITEM",
      "description": "Stars a channel, file, file comment, or a specific message in Slack.",
      "inputSchema": {
        "type": "object",
        "title": "AddAStarToAnItemRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F1234567890",
              "F0987654321"
            ],
            "description": "ID of the file to add a star to."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0123456789"
            ],
            "description": "ID of the channel to star. If starring a specific message, this is the ID of the channel containing the message, and `timestamp` must also be provided."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1234567890.123456",
              "1678886400.000100"
            ],
            "description": "Timestamp of the message to add a star to. This uniquely identifies the message within the specified `channel`. Requires `channel` to also be provided."
          },
          "file_comment": {
            "type": "string",
            "title": "File Comment",
            "examples": [
              "Fc1234567890",
              "Fc0987654321"
            ],
            "description": "ID of the file comment to add a star to."
          }
        },
        "description": "Request schema for the `stars.add` API method. Used to add a star to a channel, file, file comment, or a specific message. Exactly one type of item must be targeted per request."
      }
    },
    {
      "name": "SLACKBOT_ADD_CALL_PARTICIPANTS",
      "description": "Registers new participants added to a Slack call.",
      "inputSchema": {
        "type": "object",
        "title": "AddCallParticipantsRequest",
        "required": [
          "id",
          "users"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123456789"
            ],
            "description": "ID of the call returned by the add method."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]",
              "[{\"slack_id\": \"U2ABC123\"}]"
            ],
            "description": "The list of users to add as participants in the call. users is a JSON array (formatted as a string) containing information for each user. Each element should include both a `slack_id` and optionally an `external_id`. For example: `[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]`."
          }
        },
        "description": "Request schema for `AddCallParticipants`"
      }
    },
    {
      "name": "SLACKBOT_ADD_EMOJI",
      "description": "Adds a custom emoji to a Slack workspace given a unique name and an image URL; subject to workspace emoji limits.",
      "inputSchema": {
        "type": "object",
        "title": "AddEmojiRequest",
        "required": [
          "name",
          "token",
          "url"
        ],
        "properties": {
          "url": {
            "type": "string",
            "title": "Url",
            "examples": [
              "https://example.com/emoji/partyparrot.gif",
              "https://cdn.example.com/images/approved_stamp.png"
            ],
            "description": "The URL of the image file to be used as the custom emoji. The image should be accessible via HTTP/HTTPS and meet Slack's emoji requirements (e.g., size, format). Supported formats typically include PNG, GIF, and JPEG."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "partyparrot",
              "approved_stamp",
              "team_logo_small"
            ],
            "description": "The desired name for the new custom emoji. This name will be used to invoke the emoji (e.g., if name is 'partyparrot', it's used as ':partyparrot:'). Colons around the name are not required when providing this field."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token used to authorize the request to add a custom emoji to the Slack workspace."
          }
        },
        "description": "Request schema for `AddEmoji`"
      }
    },
    {
      "name": "SLACKBOT_ADD_REACTION_TO_AN_ITEM",
      "description": "Adds a specified emoji reaction to an existing message in a Slack channel, identified by its timestamp; does not remove or retrieve reactions.",
      "inputSchema": {
        "type": "object",
        "title": "AddReactionToAnItemRequest",
        "required": [
          "channel",
          "name",
          "timestamp"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "thumbsup",
              "grinning",
              "robot_face",
              "wave::skin-tone-3"
            ],
            "description": "Name of the emoji to add as a reaction (e.g., 'thumbsup'). This is the emoji name without colons. For emojis with skin tone modifiers, append '::skin-tone-X' where X is a number from 2 to 6 (e.g., 'wave::skin-tone-3')."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321"
            ],
            "description": "ID of the channel where the message to add the reaction to was posted."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1234567890.123456",
              "1609459200.000200"
            ],
            "description": "Timestamp of the message to which the reaction will be added. This is a unique identifier for the message, typically a string representing a float value like '1234567890.123456'."
          }
        },
        "description": "Request schema for `AddReactionToAnItem`"
      }
    },
    {
      "name": "SLACKBOT_ARCHIVE_A_CONVERSATION",
      "description": "Archives a Slack conversation by its ID, rendering it read-only and hidden while retaining history, ideal for cleaning up inactive channels; be aware that some channels (like #general or certain DMs) cannot be archived and this may impact connected integrations.",
      "inputSchema": {
        "type": "object",
        "title": "ArchiveASlackConversationRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "ID of the Slack conversation to archive. This ID uniquely identifies a channel (e.g., public, private)."
          }
        },
        "description": "Request schema for `ArchiveASlackConversation`"
      }
    },
    {
      "name": "SLACKBOT_ARCHIVE_A_PUBLIC_OR_PRIVATE_CHANNEL",
      "description": "Archives a Slack public or private channel, making it read-only; the primary 'general' channel cannot be archived.",
      "inputSchema": {
        "type": "object",
        "title": "ArchiveAPublicOrPrivateChannelRequest",
        "required": [
          "channel_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C1234567890"
            ],
            "description": "ID of the public or private Slack channel to archive."
          }
        },
        "description": "Request schema for `ArchiveAPublicOrPrivateChannel`"
      }
    },
    {
      "name": "SLACKBOT_CHAT_POST_MESSAGE",
      "description": "DEPRECATED: Posts a message to a Slack channel, direct message, or private channel. Use `send_message` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SendMessageRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello from your friendly bot!",
              "Reminder: Team meeting at 3 PM today."
            ],
            "description": "DEPRECATED: This sends raw text only, use markdown_text field. Primary textual content. Recommended fallback if using `blocks` or `attachments`. Supports mrkdwn unless `mrkdwn` is `false`."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "none",
              "full"
            ],
            "description": "Message text parsing behavior. Default `none` (no special parsing). `full` parses as user-typed (links @mentions, #channels). See Slack API docs for details."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "%5B%7B%22type%22%3A%20%22section%22%2C%20%22text%22%3A%20%7B%22type%22%3A%20%22mrkdwn%22%2C%20%22text%22%3A%20%22Hello%2C%20world%21%22%7D%7D%5D"
            ],
            "description": "DEPRECATED: Use `markdown_text` field instead. URL-encoded JSON array of layout blocks for rich/interactive messages. See Slack API Block Kit docs for structure."
          },
          "mrkdwn": {
            "type": "boolean",
            "title": "Mrkdwn",
            "description": "Disable Slack's markdown for `text` field if `false`. Default `true` (allows *bold*, _italic_, etc.)."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "Post as the authenticated user instead of as a bot. Defaults to `false`. If `true`, `username`, `icon_emoji`, and `icon_url` are ignored. If `false`, the message is posted as a bot, allowing appearance customization."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "ID or name of the channel, private group, or IM channel to send the message to."
          },
          "icon_url": {
            "type": "string",
            "title": "Icon Url",
            "examples": [
              "https://slack.com/img/icons/appDir_2019_01/Tonito64.png"
            ],
            "description": "Image URL for bot's icon (must be HTTPS). Applies if `as_user` is `false`."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "examples": [
              "MyBot",
              "AlertBot"
            ],
            "description": "Bot's name in Slack (max 80 chars). Applies if `as_user` is `false`."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "examples": [
              "1618033790.001500"
            ],
            "description": "Timestamp (`ts`) of an existing message to make this a threaded reply. Use `ts` of the parent message, not another reply. Example: '1476746824.000004'."
          },
          "icon_emoji": {
            "type": "string",
            "title": "Icon Emoji",
            "examples": [
              ":tada:",
              ":slack:"
            ],
            "description": "Emoji for bot's icon (e.g., ':robot_face:'). Overrides `icon_url`. Applies if `as_user` is `false`."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "description": "Automatically hyperlink channel names (e.g., #channel) and usernames (e.g., @user) in message text. Defaults to `false` for bot messages."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "%5B%7B%22fallback%22%3A%20%22Required%20plain-text%20summary%20of%20the%20attachment.%22%2C%20%22color%22%3A%20%22%2336a64f%22%2C%20%22pretext%22%3A%20%22Optional%20text%20that%20appears%20above%20the%20attachment%20block%22%2C%20%22author_name%22%3A%20%22Bobby%20Tables%22%2C%20%22title%22%3A%20%22Slack%20API%20Documentation%22%2C%20%22title_link%22%3A%20%22https%3A%2F%2Fapi.slack.com%2F%22%2C%20%22text%22%3A%20%22Optional%20text%20that%20appears%20within%20the%20attachment%22%7D%5D"
            ],
            "description": "URL-encoded JSON array of message attachments, a legacy method for rich content. See Slack API documentation for structure."
          },
          "unfurl_links": {
            "type": "boolean",
            "title": "Unfurl Links",
            "description": "Enable unfurling of text-based URLs. Defaults `false` for bots, `true` if `as_user` is `true`."
          },
          "unfurl_media": {
            "type": "boolean",
            "title": "Unfurl Media",
            "description": "Disable unfurling of media content from URLs if `false`. Defaults to `true`."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Status Update\n\nSystem is **running smoothly** with *excellent* performance.\n\n```bash\nkubectl get pods\n```\n\n> All services operational \u2705",
              "## Daily Report\n\n- **Deployments**: 5 successful\n- *Issues*: 0 critical\n- ~~Maintenance~~: **Completed**\n\n---\n\n**Next**: Monitor for 24h"
            ],
            "description": "PREFERRED: Write your message in markdown for nicely formatted display. Supports: headers (# ## ###), bold (**text** or __text__), italic (*text* or _text_), strikethrough (~~text~~), inline code (`code`), code blocks (```), links ([text](url)), block quotes (>), lists (- item, 1. item), dividers (--- or ***), context blocks (:::context with images), and section buttons (:::section-button). IMPORTANT: Use \\n for line breaks (e.g., 'Line 1\\nLine 2'), not actual newlines. USER MENTIONS: To tag users, use their user ID with <@USER_ID> format (e.g., <@U1234567890>), not username. "
          },
          "reply_broadcast": {
            "type": "boolean",
            "title": "Reply Broadcast",
            "description": "If `true` for a threaded reply, also posts to main channel. Defaults to `false`."
          }
        },
        "description": "Request schema for `SendMessage`"
      }
    },
    {
      "name": "SLACKBOT_CLEAR_STATUS",
      "description": "Clears the Slack status for the authenticated user, removing any custom text and emoji.",
      "inputSchema": {
        "type": "object",
        "title": "ClearStatusRequest",
        "properties": {},
        "description": "Request to clear the user's Slack status. No parameters needed."
      }
    },
    {
      "name": "SLACKBOT_CLOSE_DM_OR_MULTI_PERSON_DM",
      "description": "Closes a Slack direct message (DM) or multi-person direct message (MPDM) channel, removing it from the user's sidebar without deleting history; this action affects only the calling user's view.",
      "inputSchema": {
        "type": "object",
        "title": "CloseDmOrMultiPersonDmRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "D1234567890",
              "G0123456789"
            ],
            "description": "The ID of the direct message or multi-person direct message channel to close. Example: D1234567890 or G0123456789."
          }
        },
        "description": "Request schema for `CloseDmOrMultiPersonDm`"
      }
    },
    {
      "name": "SLACKBOT_CREATE_A_REMINDER",
      "description": "Creates a Slack reminder with specified text and time; time accepts Unix timestamps, seconds from now, or natural language (e.g., 'in 15 minutes', 'every Thursday at 2pm').",
      "inputSchema": {
        "type": "object",
        "title": "CreateAReminderRequest",
        "required": [
          "text",
          "time"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Submit weekly report",
              "Follow up with Jane Doe"
            ],
            "description": "The textual content of the reminder message."
          },
          "time": {
            "type": "string",
            "title": "Time",
            "examples": [
              "1735689600",
              "900",
              "in 20 minutes",
              "every Monday at 10am"
            ],
            "description": "Specifies when the reminder should occur. This can be a Unix timestamp (integer, up to five years from now), the number of seconds until the reminder (integer, if within 24 hours, e.g., '300' for 5 minutes), or a natural language description (string, e.g., \"in 15 minutes,\" or \"every Thursday at 2pm\", \"daily\"). "
          },
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U012AB3CD4E",
              "W1234567890"
            ],
            "description": "The ID of the user who will receive the reminder (e.g., 'U012AB3CD4E'). If not specified, the reminder will be sent to the user who created it. "
          }
        },
        "description": "Request schema for creating a new reminder in Slack."
      }
    },
    {
      "name": "SLACKBOT_CREATE_A_USER_GROUP",
      "description": "Creates a new User Group (often referred to as a subteam) in a Slack workspace.",
      "inputSchema": {
        "type": "object",
        "title": "CreateASlackUserGroupRequest",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "Customer Support",
              "Core Engineering",
              "Project Phoenix Leads"
            ],
            "description": "Unique name for the User Group. Must be unique among all User Groups in the workspace."
          },
          "handle": {
            "type": "string",
            "title": "Handle",
            "examples": [
              "support-team",
              "devs",
              "project-phoenix-leads"
            ],
            "description": "Unique mention handle. Must be unique across channels, users, and other User Groups. Max 21 chars; lowercase letters, numbers, hyphens, underscores only."
          },
          "channels": {
            "type": "string",
            "title": "Channels",
            "examples": [
              "C012AB3CD,C023BC4DE",
              "C034CD5EF"
            ],
            "description": "Comma-separated encoded channel IDs for default channels, suggested when mentioning or inviting the group."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "examples": [
              "Manages all customer support inquiries.",
              "Core engineering team members."
            ],
            "description": "Short description for the User Group."
          },
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "description": "Include the User Group's user count in the response. Server defaults to `false` if omitted."
          }
        },
        "description": "Request schema for `CreateASlackUserGroup`"
      }
    },
    {
      "name": "SLACKBOT_CREATE_CANVAS",
      "description": "Creates a new Slack Canvas with the specified title and optional content.",
      "inputSchema": {
        "type": "object",
        "title": "CreateCanvasRequest",
        "required": [
          "title"
        ],
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Project Planning",
              "Team Meeting Notes",
              "Sprint Retrospective"
            ],
            "maxLength": 255,
            "description": "The title of the canvas to create"
          },
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "default": null,
            "examples": [
              "C1234567890"
            ],
            "nullable": true,
            "description": "Optional channel ID (e.g., 'C1234567890'). If provided, the canvas will be automatically added as a tab in this channel with write permissions."
          },
          "document_content": {
            "type": "object",
            "title": "Document Content",
            "default": null,
            "examples": [
              {
                "type": "markdown",
                "markdown": "# Welcome\n\nThis is a new canvas"
              }
            ],
            "nullable": true,
            "description": "Optional canvas content in Slack's document format. If not provided, creates an empty canvas.",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "SLACKBOT_CREATE_CHANNEL",
      "description": "Initiates a public or private channel-based conversation",
      "inputSchema": {
        "type": "object",
        "title": "CreateChannelRequest",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "mychannel"
            ],
            "description": "Name of the public or private channel to create"
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "default": null,
            "examples": [
              "T1234567890"
            ],
            "nullable": true,
            "description": "encoded team id to create the channel in, required if org token is used"
          },
          "is_private": {
            "type": "boolean",
            "title": "Is Private",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Create a private channel instead of a public one"
          }
        },
        "description": "Request schema for `CreateChannel`"
      }
    },
    {
      "name": "SLACKBOT_CREATE_CHANNEL_BASED_CONVERSATION",
      "description": "Creates a new public or private Slack channel with a unique name; the channel can be org-wide, or team-specific if `team_id` is given (required if `org_wide` is false or not provided).",
      "inputSchema": {
        "type": "object",
        "title": "CreateChannelBasedConversationRequest",
        "required": [
          "is_private",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "project-alpha",
              "marketing-campaign-q3",
              "team-devs-internal"
            ],
            "description": "Name for the new channel. Must be unique, 80 characters or fewer, lowercase, without spaces or periods, and may contain letters, numbers, and hyphens."
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "examples": [
              "T123ABCDEFG"
            ],
            "description": "Workspace (team) ID for channel creation (e.g., T123ABCDEFG). Required if `org_wide` is `false` or not set."
          },
          "org_wide": {
            "type": "boolean",
            "title": "Org Wide",
            "description": "Set to `true` to make the channel available org-wide. If `false` or not set, `team_id` is required."
          },
          "is_private": {
            "type": "boolean",
            "title": "Is Private",
            "description": "Set to `true` to make the channel private, or `false` for public."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Optional description for the channel (e.g., 'Discussion about Q4 marketing strategies')."
          }
        },
        "description": "Request schema for `CreateChannelBasedConversation`"
      }
    },
    {
      "name": "SLACKBOT_CUSTOMIZE_URL_UNFURL",
      "description": "Customizes URL previews (unfurling) in a specific Slack message using a URL-encoded JSON in `unfurls` to define custom content or remove existing previews.",
      "inputSchema": {
        "type": "object",
        "title": "CustomizeUrlUnfurlRequest",
        "required": [
          "channel",
          "ts"
        ],
        "properties": {
          "ts": {
            "type": "string",
            "title": "Ts",
            "examples": [
              "1234567890.123456"
            ],
            "description": "Timestamp of the message to customize URL unfurling for."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name."
          },
          "unfurls": {
            "type": "string",
            "title": "Unfurls",
            "examples": [
              "%7B%22https%3A%2F%2Fexample.com%2Farticle%22%3A%7B%22text%22%3A%22Article%20Preview%22%7D%7D"
            ],
            "description": "URL-encoded JSON mapping message URLs to custom unfurl content (Slack attachment format or unfurl blocks). To remove an existing unfurl, provide an empty unfurl block for its URL."
          },
          "user_auth_url": {
            "type": "string",
            "title": "User Auth Url",
            "examples": [
              "https://yourapp.com/slack/auth?user_id=U123&channel_id=C123"
            ],
            "description": "URL-encoded custom URL for user authentication with your app to enable unfurling. Used when `user_auth_required` is true."
          },
          "user_auth_message": {
            "type": "string",
            "title": "User Auth Message",
            "examples": [
              "Please authenticate with MyApp to see rich previews for example.com."
            ],
            "description": "Ephemeral message text prompting user authentication with your app for domain-specific unfurling. Used when `user_auth_required` is true and authorization is pending."
          },
          "user_auth_required": {
            "type": "boolean",
            "title": "User Auth Required",
            "examples": [
              true,
              false
            ],
            "description": "Set to `true` if user authentication is required to unfurl links for a domain, enabling an authentication flow using `user_auth_url` and `user_auth_message`."
          }
        },
        "description": "Request schema for `CustomizeUrlUnfurl`"
      }
    },
    {
      "name": "SLACKBOT_CUSTOMIZE_URL_UNFURLING_IN_MESSAGES",
      "description": "DEPRECATED: Customizes URL previews (unfurling) in a specific Slack message. Use `customize_url_unfurl` instead.",
      "inputSchema": {
        "type": "object",
        "title": "CustomizeUrlUnfurlRequest",
        "required": [
          "channel",
          "ts"
        ],
        "properties": {
          "ts": {
            "type": "string",
            "title": "Ts",
            "examples": [
              "1234567890.123456"
            ],
            "description": "Timestamp of the message to customize URL unfurling for."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name."
          },
          "unfurls": {
            "type": "string",
            "title": "Unfurls",
            "examples": [
              "%7B%22https%3A%2F%2Fexample.com%2Farticle%22%3A%7B%22text%22%3A%22Article%20Preview%22%7D%7D"
            ],
            "description": "URL-encoded JSON mapping message URLs to custom unfurl content (Slack attachment format or unfurl blocks). To remove an existing unfurl, provide an empty unfurl block for its URL."
          },
          "user_auth_url": {
            "type": "string",
            "title": "User Auth Url",
            "examples": [
              "https://yourapp.com/slack/auth?user_id=U123&channel_id=C123"
            ],
            "description": "URL-encoded custom URL for user authentication with your app to enable unfurling. Used when `user_auth_required` is true."
          },
          "user_auth_message": {
            "type": "string",
            "title": "User Auth Message",
            "examples": [
              "Please authenticate with MyApp to see rich previews for example.com."
            ],
            "description": "Ephemeral message text prompting user authentication with your app for domain-specific unfurling. Used when `user_auth_required` is true and authorization is pending."
          },
          "user_auth_required": {
            "type": "boolean",
            "title": "User Auth Required",
            "examples": [
              true,
              false
            ],
            "description": "Set to `true` if user authentication is required to unfurl links for a domain, enabling an authentication flow using `user_auth_url` and `user_auth_message`."
          }
        },
        "description": "Request schema for `CustomizeUrlUnfurl`"
      }
    },
    {
      "name": "SLACKBOT_DELETE_A_COMMENT_ON_A_FILE",
      "description": "Deletes a specific comment from a file in Slack; this action is irreversible.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteACommentOnAFileRequest",
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "Fc1234567890"
            ],
            "description": "ID of the comment to delete. This can be obtained when the comment is created or by listing file comments."
          },
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F1234567890"
            ],
            "description": "ID of the file to delete a comment from. The file ID can be obtained using the `files.info` method or when a file is shared."
          }
        },
        "description": "Request schema for `DeleteACommentOnAFile`"
      }
    },
    {
      "name": "SLACKBOT_DELETE_A_FILE_BY_ID",
      "description": "Permanently deletes an existing file from a Slack workspace using its unique file ID; this action is irreversible and also removes any associated comments or shares.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteAFileByIdRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F2147483002",
              "F012345AB67"
            ],
            "description": "ID of the file to delete. Typically obtained when a file is uploaded or listed."
          }
        },
        "description": "Request schema for `DeleteAFileById`"
      }
    },
    {
      "name": "SLACKBOT_DELETE_A_PUBLIC_OR_PRIVATE_CHANNEL",
      "description": "Permanently and irreversibly deletes a specified public or private channel, including all its messages and files, within a Slack Enterprise Grid organization.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteAPublicOrPrivateChannelRequest",
        "required": [
          "channel_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C0123456789"
            ],
            "description": "ID of the channel to be permanently deleted. This channel can be public or private."
          }
        },
        "description": "Request to delete a public or private channel."
      }
    },
    {
      "name": "SLACKBOT_DELETE_A_REMINDER",
      "description": "Deletes an existing Slack reminder, typically when it is no longer relevant or a task is completed; this operation is irreversible.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteASlackReminderRequest",
        "properties": {
          "reminder": {
            "type": "string",
            "title": "Reminder",
            "examples": [
              "Rm1234567890"
            ],
            "description": "The unique identifier of the reminder to be deleted. This ID is obtained when a reminder is created or listed."
          }
        },
        "description": "Request schema for deleting a Slack reminder."
      }
    },
    {
      "name": "SLACKBOT_DELETE_A_SCHEDULED_MESSAGE_IN_A_CHAT",
      "description": "Deletes a pending, unsent scheduled message from the specified Slack channel, identified by its `scheduled_message_id`.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteAScheduledMessageInAChatRequest",
        "required": [
          "channel",
          "scheduled_message_id"
        ],
        "properties": {
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "examples": [
              "true",
              "false"
            ],
            "description": "Pass `true` to delete the message as the authenticated user (bots are considered authed users here, uses `chat:write:user` scope); if `false` or omitted, deletes as a bot (uses `chat:write:bot` scope)."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0123456789",
              "D0123456789"
            ],
            "description": "ID of the channel, private group, or DM conversation where the message is scheduled."
          },
          "scheduled_message_id": {
            "type": "string",
            "title": "Scheduled Message Id",
            "examples": [
              "Q123ABCDEF456",
              "SM0123456789"
            ],
            "description": "Unique ID (`scheduled_message_id`) of the message to be deleted; obtained from `chat.scheduleMessage` response."
          }
        },
        "description": "Request schema for `DeleteAScheduledMessageInAChat`"
      }
    },
    {
      "name": "SLACKBOT_DELETE_CANVAS",
      "description": "Deletes a Slack Canvas permanently.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteCanvasRequest",
        "required": [
          "canvas_id"
        ],
        "properties": {
          "canvas_id": {
            "type": "string",
            "title": "Canvas Id",
            "examples": [
              "F01234ABCDE"
            ],
            "description": "The unique identifier of the canvas to delete"
          }
        }
      }
    },
    {
      "name": "SLACKBOT_DELETES_A_MESSAGE_FROM_A_CHAT",
      "description": "Deletes a message, identified by its channel ID and timestamp, from a Slack channel, private group, or direct message conversation; the authenticated user or bot must be the original poster.",
      "inputSchema": {
        "type": "object",
        "title": "DeletesAMessageFromAChatRequest",
        "properties": {
          "ts": {
            "type": "string",
            "title": "Ts",
            "examples": [
              "1234567890.123456",
              "1609459200.000000"
            ],
            "description": "Timestamp of the message to be deleted. Must be the exact Slack message timestamp string with fractional precision, e.g., '1234567890.123456'."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "If `True`, deletes the message as the authenticated user using the `chat:write:user` scope. Bot users are considered authenticated users. If `False` or omitted, the message is deleted using the `chat:write:bot` scope."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321",
              "D060123ABC"
            ],
            "description": "The ID of the channel, private group, or direct message conversation containing the message to be deleted."
          }
        },
        "description": "Request schema for `DeletesAMessageFromAChat`"
      }
    },
    {
      "name": "SLACKBOT_DELETE_USER_PROFILE_PHOTO",
      "description": "Deletes the Slack profile photo for the user identified by the token, reverting them to the default avatar; this action is irreversible and succeeds even if no custom photo was set.",
      "inputSchema": {
        "type": "object",
        "title": "DeleteUserProfilePhotoRequest",
        "required": [
          "token"
        ],
        "properties": {
          "token": {
            "type": "string",
            "title": "Token",
            "examples": [
              "xoxp-YOUR_SLACK_LEGACY_TOKEN"
            ],
            "description": "Authentication token identifying the user whose profile photo will be deleted."
          }
        },
        "description": "Input for deleting a user's profile photo."
      }
    },
    {
      "name": "SLACKBOT_DISABLE_AN_EXISTING_USER_GROUP",
      "description": "Disables a specified, currently enabled Slack User Group by its unique ID, effectively archiving it by setting its 'date_delete' timestamp; the group is not permanently deleted and can be re-enabled.",
      "inputSchema": {
        "type": "object",
        "title": "DisableAnExistingSlackUserGroupRequest",
        "required": [
          "usergroup"
        ],
        "properties": {
          "usergroup": {
            "type": "string",
            "title": "Usergroup",
            "examples": [
              "S0123ABCDEF",
              "S0604QSJC"
            ],
            "description": "Unique encoded ID of the User Group to disable."
          },
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "examples": [
              "true",
              "false"
            ],
            "description": "If true, include the number of users in the User Group in the response."
          }
        },
        "description": "Request schema for `DisableAnExistingSlackUserGroup`"
      }
    },
    {
      "name": "SLACKBOT_EDIT_CANVAS",
      "description": "Edits a Slack Canvas with granular control over content placement. Supports replace, insert (before/after/start/end) operations for flexible content management.",
      "inputSchema": {
        "type": "object",
        "title": "EditCanvasRequest",
        "required": [
          "canvas_id"
        ],
        "properties": {
          "canvas_id": {
            "type": "string",
            "title": "Canvas Id",
            "examples": [
              "F01234ABCDE"
            ],
            "description": "The unique identifier of the canvas to edit"
          },
          "operation": {
            "enum": [
              "replace",
              "insert_after",
              "insert_before",
              "insert_at_start",
              "insert_at_end",
              "delete"
            ],
            "type": "string",
            "title": "Operation",
            "default": "replace",
            "description": "Type of edit operation: 'replace' (replaces entire canvas or specific section if section_id provided), 'insert_after' (inserts content after section_id), 'insert_before' (inserts content before section_id), 'insert_at_start' (prepends content to beginning), 'insert_at_end' (appends content to end), 'delete' (deletes specific section by section_id)"
          },
          "section_id": {
            "type": "string",
            "title": "Section Id",
            "default": null,
            "examples": [
              "temp:C:VXX8e648e6984e441c6aa8c61173",
              "section-abc-123"
            ],
            "nullable": true,
            "description": "Section ID for targeted operations. Required for: 'insert_after', 'insert_before', 'delete'. Optional for: 'replace' (if omitted, replaces entire canvas). Not used for: 'insert_at_start', 'insert_at_end'. Use canvases.sections.lookup method to get section IDs from existing canvas."
          },
          "document_content": {
            "type": "object",
            "title": "Document Content",
            "default": null,
            "examples": [
              {
                "type": "markdown",
                "markdown": "# New Content\n\nContent here"
              }
            ],
            "nullable": true,
            "description": "The content to add/replace in Slack's document format. Required for all operations except 'delete'. Use canvases.sections.lookup to find section IDs for targeted operations.",
            "additionalProperties": true
          }
        }
      }
    },
    {
      "name": "SLACKBOT_ENABLE_A_SPECIFIED_USER_GROUP",
      "description": "Enables a disabled User Group in Slack using its ID, reactivating it for mentions and permissions; this action only changes the enabled status and cannot create new groups or modify other properties.",
      "inputSchema": {
        "type": "object",
        "title": "EnableASpecifiedUserGroupRequest",
        "required": [
          "usergroup"
        ],
        "properties": {
          "usergroup": {
            "type": "string",
            "title": "Usergroup",
            "examples": [
              "S0604QSJC"
            ],
            "description": "The unique encoded ID of the User Group to enable. This ID typically starts with 'S'."
          },
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "examples": [
              "true",
              "false"
            ],
            "description": "If true, includes the count of users in the User Group in the response."
          }
        },
        "description": "Request schema for `EnableASpecifiedUserGroup`"
      }
    },
    {
      "name": "SLACKBOT_ENABLE_PUBLIC_SHARING_OF_A_FILE",
      "description": "Enables public sharing for an existing Slack file by generating a publicly accessible URL; this action does not create new files.",
      "inputSchema": {
        "type": "object",
        "title": "EnablePublicSharingOfAFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F0123456789"
            ],
            "description": "The ID of the file to be shared publicly."
          }
        },
        "description": "Request schema for `EnablePublicSharingOfAFile`"
      }
    },
    {
      "name": "SLACKBOT_END_A_CALL_WITH_DURATION_AND_ID",
      "description": "Ends an ongoing Slack call, identified by its ID (obtained from `calls.add`), optionally specifying the call's duration.",
      "inputSchema": {
        "type": "object",
        "title": "EndACallWithDurationAndIdRequest",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123456789"
            ],
            "description": "Unique identifier of the call to be ended, obtained from the `calls.add` method."
          },
          "duration": {
            "type": "integer",
            "title": "Duration",
            "examples": [
              "600",
              "3600"
            ],
            "description": "Duration of the call in seconds."
          }
        },
        "description": "Request schema for `EndACallWithDurationAndId`"
      }
    },
    {
      "name": "SLACKBOT_END_SNOOZE",
      "description": "Ends the current user's snooze mode immediately.",
      "inputSchema": {
        "type": "object",
        "title": "EndSnoozeRequest",
        "properties": {},
        "description": "Request schema for `EndSnooze`"
      }
    },
    {
      "name": "SLACKBOT_END_USER_DO_NOT_DISTURB_SESSION",
      "description": "Ends the authenticated user's current Do Not Disturb (DND) session in Slack, affecting only DND status and making them available; if DND is not active, Slack acknowledges the request without changing status.",
      "inputSchema": {
        "type": "object",
        "title": "EndUserDoNotDisturbSessionRequest",
        "properties": {},
        "description": "Request schema for `EndUserDoNotDisturbSession`"
      }
    },
    {
      "name": "SLACKBOT_END_USER_SNOOZE_MODE_IMMEDIATELY",
      "description": "DEPRECATED: Ends the current user's snooze mode immediately. Use `end_snooze` instead.",
      "inputSchema": {
        "type": "object",
        "title": "EndSnoozeRequest",
        "properties": {},
        "description": "Request schema for `EndSnooze`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_BOT_USER_INFORMATION",
      "description": "Fetches information for a specified, existing Slack bot user; will not work for regular user accounts or other integration types.",
      "inputSchema": {
        "type": "object",
        "title": "FetchBotUserInformationRequest",
        "properties": {
          "bot": {
            "type": "string",
            "title": "Bot",
            "examples": [
              "B0123456789"
            ],
            "description": "The ID of the bot user to retrieve information for. This typically starts with 'B'."
          }
        },
        "description": "Request schema for `FetchBotUserInformation`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_CONVERSATION_HISTORY",
      "description": "Fetches a chronological list of messages and events from a specified Slack conversation, accessible by the authenticated user/bot, with options for pagination and time range filtering.",
      "inputSchema": {
        "type": "object",
        "title": "FetchConversationHistoryRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "200"
            ],
            "description": "Maximum number of messages to return per page (1-1000). Fewer may be returned if at the end of history or channel has fewer messages."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZUVDA="
            ],
            "description": "Pagination cursor from `next_cursor` of a previous response to fetch subsequent pages. See Slack's pagination documentation for details."
          },
          "latest": {
            "type": "string",
            "title": "Latest",
            "default": null,
            "examples": [
              "1609459200.000000"
            ],
            "nullable": true,
            "description": "End of the time range of messages to include in results. Accepts a Unix timestamp or a Slack timestamp (e.g., '1234567890.000000')."
          },
          "oldest": {
            "type": "string",
            "title": "Oldest",
            "default": null,
            "examples": [
              "1609372800.000000"
            ],
            "nullable": true,
            "description": "Start of the time range of messages to include in results. Accepts a Unix timestamp or a Slack timestamp (e.g., '1234567890.000000')."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0123456789",
              "D0123456789"
            ],
            "description": "The ID of the public channel, private channel, direct message, or multi-person direct message to fetch history from."
          },
          "inclusive": {
            "type": "boolean",
            "title": "Inclusive",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include messages with `latest` or `oldest` timestamps in the results; applies only when `latest` or `oldest` is specified."
          }
        },
        "description": "Request schema for fetching conversation history from Slack."
      }
    },
    {
      "name": "SLACKBOT_FETCH_CURRENT_TEAM_INFO_WITH_OPTIONAL_TEAM_SCOPE",
      "description": "DEPRECATED: Fetches comprehensive metadata about the current Slack team. Use `fetch_team_info` instead.",
      "inputSchema": {
        "type": "object",
        "title": "FetchTeamInfoRequest",
        "properties": {
          "team": {
            "type": "string",
            "title": "Team",
            "default": null,
            "examples": [
              "T12345678",
              "E87654321"
            ],
            "nullable": true,
            "description": "The ID of the team to retrieve information for. If omitted, information for the current team (associated with the authentication token) is returned. The token must have permissions to view the specified team, especially for teams accessible via external shared channels."
          }
        },
        "description": "Request schema for `FetchTeamInfo`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_DND_STATUS_FOR_MULTIPLE_TEAM_MEMBERS",
      "description": "DEPRECATED: Retrieves a user's current Do Not Disturb status. Use `get_team_dnd_status` instead.",
      "inputSchema": {
        "type": "object",
        "title": "GetTeamDndStatusRequest",
        "required": [
          "users"
        ],
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U1234,U5678"
            ],
            "description": "Comma-separated list of users to fetch Do Not Disturb status for"
          }
        },
        "description": "Request schema for `GetTeamDndStatus`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_ITEM_REACTIONS",
      "description": "Fetches reactions for a Slack message, file, or file comment, requiring one of: channel and timestamp; file ID; or file comment ID.",
      "inputSchema": {
        "type": "object",
        "title": "FetchItemReactionsRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F1234567890",
              "F2147483002"
            ],
            "description": "File ID. Use instead of channel/timestamp or file comment ID."
          },
          "full": {
            "type": "boolean",
            "title": "Full",
            "description": "If true, returns the complete list of users for each reaction."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "C061F7XAZ"
            ],
            "description": "Channel ID. Required if `timestamp` is provided and no file or file comment ID is given."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1234567890.123456",
              "1629876543.000100"
            ],
            "description": "Message timestamp (e.g., '1234567890.123456'). Required if `channel` is provided and no file or file comment ID is given."
          },
          "file_comment": {
            "type": "string",
            "title": "File Comment",
            "examples": [
              "Fc1234567890",
              "Fc789123456"
            ],
            "description": "File comment ID. Use instead of channel/timestamp or file ID."
          }
        },
        "description": "Request schema for `FetchItemReactions` action. It specifies the item (message, file, or file comment) for which to retrieve reactions."
      }
    },
    {
      "name": "SLACKBOT_FETCH_MESSAGE_THREAD_FROM_A_CONVERSATION",
      "description": "Retrieves replies to a specific parent message in a Slack conversation, using the channel ID and the parent message's timestamp (`ts`).",
      "inputSchema": {
        "type": "object",
        "title": "FetchMessageThreadFromAConversationRequest",
        "properties": {
          "ts": {
            "type": "string",
            "title": "Ts",
            "examples": [
              "1234567890.123456"
            ],
            "description": "Timestamp of the parent message in the thread. Must be an existing message. If no replies, only the parent message itself is returned."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              100
            ],
            "description": "Maximum number of messages to return. Fewer may be returned even if more are available."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMEc5V0ZYTlo="
            ],
            "description": "Pagination cursor from `response_metadata.next_cursor` of a previous response to get subsequent pages. If omitted, fetches the first page."
          },
          "latest": {
            "type": "string",
            "title": "Latest",
            "default": null,
            "examples": [
              "1678886400.000000"
            ],
            "nullable": true,
            "description": "Latest message timestamp in the time range to include results."
          },
          "oldest": {
            "type": "string",
            "title": "Oldest",
            "default": null,
            "examples": [
              "1678836000.000000"
            ],
            "nullable": true,
            "description": "Oldest message timestamp in the time range to include results."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C0123456789"
            ],
            "description": "ID of the conversation (channel, direct message, etc.) to fetch the thread from."
          },
          "inclusive": {
            "type": "boolean",
            "title": "Inclusive",
            "examples": [
              true
            ],
            "description": "Whether to include messages with `latest` or `oldest` timestamps in results. Effective only if `latest` or `oldest` is specified."
          }
        },
        "description": "Request schema for `FetchMessageThreadFromAConversation`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_TEAM_INFO",
      "description": "Fetches comprehensive metadata about the current Slack team, or a specified team if the provided ID is accessible.",
      "inputSchema": {
        "type": "object",
        "title": "FetchTeamInfoRequest",
        "properties": {
          "team": {
            "type": "string",
            "title": "Team",
            "default": null,
            "examples": [
              "T12345678",
              "E87654321"
            ],
            "nullable": true,
            "description": "The ID of the team to retrieve information for. If omitted, information for the current team (associated with the authentication token) is returned. The token must have permissions to view the specified team, especially for teams accessible via external shared channels."
          }
        },
        "description": "Request schema for `FetchTeamInfo`"
      }
    },
    {
      "name": "SLACKBOT_FETCH_WORKSPACE_SETTINGS_INFORMATION",
      "description": "Retrieves detailed settings for a specific Slack workspace, primarily for administrators in an Enterprise Grid organization to view or audit workspace configurations.",
      "inputSchema": {
        "type": "object",
        "title": "FetchWorkspaceSettingsInformationRequest",
        "required": [
          "team_id"
        ],
        "properties": {
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "examples": [
              "T12345ABCDE"
            ],
            "description": "The unique identifier of the Slack team (workspace) for which to fetch settings. This ID typically starts with 'T'."
          }
        },
        "description": "Request schema for `FetchWorkspaceSettingsInformation`"
      }
    },
    {
      "name": "SLACKBOT_FIND_CHANNELS",
      "description": "Find channels in a Slack workspace by any criteria - name, topic, purpose, or description.",
      "inputSchema": {
        "type": "object",
        "title": "FindChannelsRequest",
        "required": [
          "search_query"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 50,
            "examples": [
              10,
              25,
              100
            ],
            "description": "Maximum number of channels to return (1 to 200). Defaults to 50."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "default": "public_channel,private_channel",
            "examples": [
              "public_channel",
              "private_channel",
              "public_channel,private_channel"
            ],
            "description": "Comma-separated list of channel types to include: `public_channel`, `private_channel`, `mpim` (multi-person direct message), `im` (direct message). Defaults to public and private channels."
          },
          "exact_match": {
            "type": "boolean",
            "title": "Exact Match",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "Use exact matching instead of partial matching. Defaults to false."
          },
          "member_only": {
            "type": "boolean",
            "title": "Member Only",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "Only return channels the user is a member of. Defaults to false."
          },
          "search_query": {
            "type": "string",
            "title": "Search Query",
            "examples": [
              "general",
              "marketing",
              "dev",
              "announcements",
              "project"
            ],
            "description": "Search query to find channels. Searches across channel name, topic, purpose, and description (case-insensitive partial matching)."
          },
          "exclude_archived": {
            "type": "boolean",
            "title": "Exclude Archived",
            "default": true,
            "examples": [
              true,
              false
            ],
            "description": "Exclude archived channels from search results. Defaults to true."
          }
        },
        "description": "Request schema for finding Slack channels by any criteria (name, topic, purpose, etc.)."
      }
    },
    {
      "name": "SLACKBOT_FIND_USER_BY_EMAIL_ADDRESS",
      "description": "Retrieves the Slack user object for an active user by their registered email address; fails with 'users_not_found' if the email is unregistered or the user is inactive.",
      "inputSchema": {
        "type": "object",
        "title": "FindUserByEmailAddressRequest",
        "required": [
          "email"
        ],
        "properties": {
          "email": {
            "type": "string",
            "title": "Email",
            "examples": [
              "sally.doe@example.com",
              "johndoe@workplace.org"
            ],
            "description": "The email address of the user to look up."
          }
        },
        "description": "Request schema for `FindUserByEmailAddress`"
      }
    },
    {
      "name": "SLACKBOT_FIND_USERS",
      "description": "Find users in a Slack workspace by any criteria - email, name, display name, or other text. Includes optimized email lookup for exact email matches.",
      "inputSchema": {
        "type": "object",
        "title": "FindUsersRequest",
        "required": [
          "search_query"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 50,
            "examples": [
              10,
              25,
              100
            ],
            "description": "Maximum number of users to return (1 to 200). Defaults to 50."
          },
          "exact_match": {
            "type": "boolean",
            "title": "Exact Match",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "Use exact matching instead of partial matching. Defaults to false."
          },
          "include_bots": {
            "type": "boolean",
            "title": "Include Bots",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "Include bot users in search results. Defaults to false."
          },
          "search_query": {
            "type": "string",
            "title": "Search Query",
            "examples": [
              "john",
              "john.doe@company.com",
              "john doe",
              "smith",
              "@company.com"
            ],
            "description": "Search query to find users. Searches across name, display name, real name, email address, first name, last name, and status text (case-insensitive partial matching). For exact email matches with exact_match=true, uses Slack's efficient email lookup endpoint."
          },
          "include_deleted": {
            "type": "boolean",
            "title": "Include Deleted",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "Include deleted/deactivated users in search results. Defaults to false."
          },
          "include_restricted": {
            "type": "boolean",
            "title": "Include Restricted",
            "default": true,
            "examples": [
              true,
              false
            ],
            "description": "Include restricted (guest) users in search results. Defaults to true."
          }
        },
        "description": "Request schema for finding Slack users by any criteria (email, name, etc.)."
      }
    },
    {
      "name": "SLACKBOT_GET_CANVAS",
      "description": "Retrieves a specific Slack Canvas by its ID, including its content and metadata.",
      "inputSchema": {
        "type": "object",
        "title": "GetCanvasRequest",
        "required": [
          "canvas_id"
        ],
        "properties": {
          "canvas_id": {
            "type": "string",
            "title": "Canvas Id",
            "examples": [
              "F01234ABCDE"
            ],
            "description": "The unique identifier of the canvas to retrieve"
          }
        }
      }
    },
    {
      "name": "SLACKBOT_GET_CHANNEL_CONVERSATION_PREFERENCES",
      "description": "Retrieves conversation preferences (e.g., who can post, who can thread) for a specified channel, primarily for use within Slack Enterprise Grid environments.",
      "inputSchema": {
        "type": "object",
        "title": "GetChannelConversationPreferencesRequest",
        "required": [
          "channel_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C0123456789"
            ],
            "description": "Identifier of the channel for which to retrieve conversation preferences."
          }
        },
        "description": "Request to retrieve conversation preferences for a Slack channel."
      }
    },
    {
      "name": "SLACKBOT_GET_REMINDER_INFORMATION",
      "description": "Retrieves detailed information for an existing Slack reminder specified by its ID; this is a read-only operation.",
      "inputSchema": {
        "type": "object",
        "title": "GetReminderInformationRequest",
        "properties": {
          "reminder": {
            "type": "string",
            "title": "Reminder",
            "examples": [
              "Rm12345678"
            ],
            "description": "The unique identifier of the reminder to retrieve information for. This ID typically starts with 'Rm'."
          }
        },
        "description": "Request schema for `GetReminderInformation` action. Specifies the reminder to be retrieved."
      }
    },
    {
      "name": "SLACKBOT_GET_REMOTE_FILE",
      "description": "Retrieve information about a remote file added to Slack.",
      "inputSchema": {
        "type": "object",
        "title": "GetRemoteFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F2147483862"
            ],
            "description": "Specify a file by providing its ID."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "123456"
            ],
            "description": "Creator defined GUID for the file."
          }
        },
        "description": "Request schema for `GetRemoteFile`"
      }
    },
    {
      "name": "SLACKBOT_GET_TEAM_DND_STATUS",
      "description": "Retrieves a user's current Do Not Disturb status.",
      "inputSchema": {
        "type": "object",
        "title": "GetTeamDndStatusRequest",
        "required": [
          "users"
        ],
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U1234,U5678"
            ],
            "description": "Comma-separated list of users to fetch Do Not Disturb status for"
          }
        },
        "description": "Request schema for `GetTeamDndStatus`"
      }
    },
    {
      "name": "SLACKBOT_GET_USER_PRESENCE_INFO",
      "description": "Retrieves a Slack user's current real-time presence (e.g., 'active', 'away') to determine their availability, noting this action does not provide historical data or status reasons.",
      "inputSchema": {
        "type": "object",
        "title": "GetUserPresenceInfoRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U012A3CDE",
              "W012A3CDE"
            ],
            "description": "The ID of the user to query for presence information. This is a string identifier, typically starting with 'U' or 'W' (e.g., 'U123ABC456'). If not provided, presence information for the authenticated user will be returned."
          }
        },
        "description": "Request schema for `GetUserPresenceInfo`"
      }
    },
    {
      "name": "SLACKBOT_INITIATES_CHANNEL_BASED_CONVERSATIONS",
      "description": "DEPRECATED: Initiates a public or private channel-based conversation. Use `create_channel` instead.",
      "inputSchema": {
        "type": "object",
        "title": "CreateChannelRequest",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "mychannel"
            ],
            "description": "Name of the public or private channel to create"
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "default": null,
            "examples": [
              "T1234567890"
            ],
            "nullable": true,
            "description": "encoded team id to create the channel in, required if org token is used"
          },
          "is_private": {
            "type": "boolean",
            "title": "Is Private",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Create a private channel instead of a public one"
          }
        },
        "description": "Request schema for `CreateChannel`"
      }
    },
    {
      "name": "SLACKBOT_INVITE_USERS_TO_A_CHANNEL",
      "description": "Invites users to an existing Slack channel using their valid Slack User IDs.",
      "inputSchema": {
        "type": "object",
        "title": "InviteUsersToASlackChannelRequest",
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U1234567890,U2345678901,U3456789012"
            ],
            "description": "Comma-separated string of valid Slack User IDs to invite. Up to 1000 user IDs can be included."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321"
            ],
            "description": "ID of the public or private Slack channel to invite users to; must be an existing channel. Typically starts with 'C' (public) or 'G' (private/group)."
          }
        },
        "description": "Request schema for `InviteUsersToASlackChannel`"
      }
    },
    {
      "name": "SLACKBOT_INVITE_USER_TO_CHANNEL",
      "description": "Invites users to a specified Slack channel; this action is restricted to Enterprise Grid workspaces and requires the authenticated user to be a member of the target channel.",
      "inputSchema": {
        "type": "object",
        "title": "InviteUserToChannelRequest",
        "required": [
          "channel_id",
          "user_ids"
        ],
        "properties": {
          "user_ids": {
            "type": "string",
            "title": "User Ids",
            "examples": [
              "U012A3CDE,U023B4DEF",
              "W12345678,W87654321"
            ],
            "description": "A comma-separated string of Slack User IDs to invite to the channel. Up to 1000 users can be specified."
          },
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C1234567890",
              "C061X2Z7W9S"
            ],
            "description": "The ID of the public or private Slack channel to which users will be invited."
          }
        },
        "description": "Request schema for `InviteUserToChannel`"
      }
    },
    {
      "name": "SLACKBOT_INVITE_USER_TO_WORKSPACE",
      "description": "Invites a user to a Slack workspace and specified channels by email; use `resend=True` to re-process an existing invitation for a user not yet signed up.",
      "inputSchema": {
        "type": "object",
        "title": "InviteUserToWorkspaceRequest",
        "required": [
          "channel_ids",
          "email",
          "team_id"
        ],
        "properties": {
          "email": {
            "type": "string",
            "title": "Email",
            "examples": [
              "new.user@example.com"
            ],
            "description": "The email address of the person to be invited to the workspace."
          },
          "resend": {
            "type": "boolean",
            "title": "Resend",
            "examples": [
              "false",
              "true"
            ],
            "description": "If true, allows this invitation to be resent if the user hasn't signed up. Defaults to false."
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "examples": [
              "T123ABCDEFG"
            ],
            "description": "The ID of the Slack workspace (e.g., T123ABCDEFG) where the user will be invited."
          },
          "real_name": {
            "type": "string",
            "title": "Real Name",
            "examples": [
              "Jane Doe"
            ],
            "description": "The full name of the user being invited."
          },
          "channel_ids": {
            "type": "string",
            "title": "Channel Ids",
            "examples": [
              "C1234567890,C9876543210",
              "C0123456789"
            ],
            "description": "A comma-separated list of channel IDs (e.g., C1234567890,C0987654321) for the user to join. At least one channel ID must be provided."
          },
          "is_restricted": {
            "type": "boolean",
            "title": "Is Restricted",
            "examples": [
              "false",
              "true"
            ],
            "description": "Specifies if the invited user should be a multi-channel guest. Defaults to false. Multi-channel guests can access only the channels they are invited to, plus any public channels."
          },
          "custom_message": {
            "type": "string",
            "title": "Custom Message",
            "examples": [
              "Welcome to the team! Looking forward to working with you."
            ],
            "description": "Custom message to include in the invitation email."
          },
          "guest_expiration_ts": {
            "type": "string",
            "title": "Guest Expiration Ts",
            "examples": [
              "1678886400"
            ],
            "description": "Unix timestamp for guest account expiration; provide only if inviting a guest user and an expiration date is desired."
          },
          "is_ultra_restricted": {
            "type": "boolean",
            "title": "Is Ultra Restricted",
            "examples": [
              "false",
              "true"
            ],
            "description": "Specifies if the invited user should be a single-channel guest (also known as an ultra-restricted guest). Defaults to false. Single-channel guests can only access one channel (plus DMs and Huddles)."
          }
        },
        "description": "Request model for inviting a user to a Slack workspace, with options to specify channels, user type, and custom messages."
      }
    },
    {
      "name": "SLACKBOT_INVITE_USER_TO_WORKSPACE_WITH_OPTIONAL_CHANNEL_INVITES",
      "description": "DEPRECATED: Invites a user to a Slack workspace and specified channels by email. Use `invite_user_to_workspace` instead.",
      "inputSchema": {
        "type": "object",
        "title": "InviteUserToWorkspaceRequest",
        "required": [
          "channel_ids",
          "email",
          "team_id"
        ],
        "properties": {
          "email": {
            "type": "string",
            "title": "Email",
            "examples": [
              "new.user@example.com"
            ],
            "description": "The email address of the person to be invited to the workspace."
          },
          "resend": {
            "type": "boolean",
            "title": "Resend",
            "examples": [
              "false",
              "true"
            ],
            "description": "If true, allows this invitation to be resent if the user hasn't signed up. Defaults to false."
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "examples": [
              "T123ABCDEFG"
            ],
            "description": "The ID of the Slack workspace (e.g., T123ABCDEFG) where the user will be invited."
          },
          "real_name": {
            "type": "string",
            "title": "Real Name",
            "examples": [
              "Jane Doe"
            ],
            "description": "The full name of the user being invited."
          },
          "channel_ids": {
            "type": "string",
            "title": "Channel Ids",
            "examples": [
              "C1234567890,C9876543210",
              "C0123456789"
            ],
            "description": "A comma-separated list of channel IDs (e.g., C1234567890,C0987654321) for the user to join. At least one channel ID must be provided."
          },
          "is_restricted": {
            "type": "boolean",
            "title": "Is Restricted",
            "examples": [
              "false",
              "true"
            ],
            "description": "Specifies if the invited user should be a multi-channel guest. Defaults to false. Multi-channel guests can access only the channels they are invited to, plus any public channels."
          },
          "custom_message": {
            "type": "string",
            "title": "Custom Message",
            "examples": [
              "Welcome to the team! Looking forward to working with you."
            ],
            "description": "Custom message to include in the invitation email."
          },
          "guest_expiration_ts": {
            "type": "string",
            "title": "Guest Expiration Ts",
            "examples": [
              "1678886400"
            ],
            "description": "Unix timestamp for guest account expiration; provide only if inviting a guest user and an expiration date is desired."
          },
          "is_ultra_restricted": {
            "type": "boolean",
            "title": "Is Ultra Restricted",
            "examples": [
              "false",
              "true"
            ],
            "description": "Specifies if the invited user should be a single-channel guest (also known as an ultra-restricted guest). Defaults to false. Single-channel guests can only access one channel (plus DMs and Huddles)."
          }
        },
        "description": "Request model for inviting a user to a Slack workspace, with options to specify channels, user type, and custom messages."
      }
    },
    {
      "name": "SLACKBOT_JOIN_AN_EXISTING_CONVERSATION",
      "description": "Joins an existing Slack conversation (public channel, private channel, or multi-person direct message) by its ID, if the authenticated user has permission.",
      "inputSchema": {
        "type": "object",
        "title": "JoinAnExistingConversationRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321",
              "D123ABCDEF0"
            ],
            "description": "ID of the Slack conversation (public channel, private channel, or multi-person direct message) to join."
          }
        },
        "description": "Request schema for `JoinAnExistingConversation`"
      }
    },
    {
      "name": "SLACKBOT_LEAVE_A_CONVERSATION",
      "description": "Leaves a Slack conversation given its channel ID; fails if leaving as the last member of a private channel or if used on a Slack Connect channel.",
      "inputSchema": {
        "type": "object",
        "title": "LeaveAConversationRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "D9876543210",
              "G12345ABCDE"
            ],
            "description": "ID of the conversation to leave (e.g., C1234567890). Despite `default=None` in the schema, this ID is functionally required by the Slack API."
          }
        },
        "description": "Specifies the channel to leave."
      }
    },
    {
      "name": "SLACKBOT_LIST_ACCESSIBLE_CONVERSATIONS_FOR_A_USER",
      "description": "DEPRECATED: Retrieves conversations accessible to a specified user. Use `list_conversations` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListAccessibleConversationsForAUserRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U123ABC456",
              "W012A3BCD"
            ],
            "description": "The ID of the user whose conversations will be listed. If not provided, conversations for the authenticated user are returned. Non-public channels are restricted to those where the calling user (authenticating user) shares membership."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "500",
              "1000"
            ],
            "description": "The maximum number of items to return per page. Must be an integer, typically between 1 and 1000 (e.g., 100). If omitted, the API's default limit (often 100) applies. Fewer items than the limit may be returned."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "examples": [
              "public_channel,private_channel",
              "im,mpim",
              "public_channel"
            ],
            "description": "A comma-separated list of conversation types to include. Valid types are `public_channel`, `private_channel`, `mpim` (multi-person direct message), and `im` (direct message). If omitted, all types are included."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0Nlc=",
              "bmV4dF90czoxNTEyMDg1ODYxMDAwNTQz"
            ],
            "description": "Pagination cursor for retrieving the next set of results. Obtain this from the `next_cursor` field in a previous response's `response_metadata`. If omitted, the first page is fetched."
          },
          "exclude_archived": {
            "type": "boolean",
            "title": "Exclude Archived",
            "examples": [
              "true",
              "false"
            ],
            "description": "Set to `true` to exclude archived channels from the list. If `false` or omitted, archived channels are typically included (the API's default behavior for omission will apply, usually including them)."
          }
        },
        "description": "Request model for listing conversations accessible to a user, with options for pagination and filtering."
      }
    },
    {
      "name": "SLACKBOT_LIST_ALL_CHANNELS",
      "description": "Lists conversations available to the user with various filters and search options.",
      "inputSchema": {
        "type": "object",
        "title": "ListAllChannelsRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 1,
            "examples": [
              100,
              500,
              1000
            ],
            "description": "Maximum number of channels to return per page (1 to 1000). Fewer channels may be returned than requested. This schema defaults to 1 if omitted."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "examples": [
              "public_channel,private_channel",
              "im,mpim"
            ],
            "description": "Comma-separated list of channel types to include: `public_channel`, `private_channel`, `mpim` (multi-person direct message), `im` (direct message). The API defaults to `public_channel` if this parameter is omitted."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZUVDI=",
              "bmV4dF90czoxNTEyMDg1ODYxMDAwNTQ5"
            ],
            "description": "Pagination cursor (from a previous response's `next_cursor`) for the next page of results. Omit for the first page."
          },
          "channel_name": {
            "type": "string",
            "title": "Channel Name",
            "examples": [
              "general",
              "announcements"
            ],
            "description": "Filter channels by name (case-insensitive substring match). This is a client-side filter applied after fetching from the API."
          },
          "exclude_archived": {
            "type": "boolean",
            "title": "Exclude Archived",
            "examples": [
              true,
              false
            ],
            "description": "Excludes archived channels if true. The API defaults to false (archived channels are included)."
          }
        },
        "description": "Request schema for listing Slack team channels with various filtering options."
      }
    },
    {
      "name": "SLACKBOT_LIST_ALL_TEAM_CHANNELS_WITH_VARIOUS_FILTERS",
      "description": "DEPRECATED: Lists conversations available to the user with various filters and search options. Use `list_channels` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListAllChannelsRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 1,
            "examples": [
              100,
              500,
              1000
            ],
            "description": "Maximum number of channels to return per page (1 to 1000). Fewer channels may be returned than requested. This schema defaults to 1 if omitted."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "examples": [
              "public_channel,private_channel",
              "im,mpim"
            ],
            "description": "Comma-separated list of channel types to include: `public_channel`, `private_channel`, `mpim` (multi-person direct message), `im` (direct message). The API defaults to `public_channel` if this parameter is omitted."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZUVDI=",
              "bmV4dF90czoxNTEyMDg1ODYxMDAwNTQ5"
            ],
            "description": "Pagination cursor (from a previous response's `next_cursor`) for the next page of results. Omit for the first page."
          },
          "channel_name": {
            "type": "string",
            "title": "Channel Name",
            "examples": [
              "general",
              "announcements"
            ],
            "description": "Filter channels by name (case-insensitive substring match). This is a client-side filter applied after fetching from the API."
          },
          "exclude_archived": {
            "type": "boolean",
            "title": "Exclude Archived",
            "examples": [
              true,
              false
            ],
            "description": "Excludes archived channels if true. The API defaults to false (archived channels are included)."
          }
        },
        "description": "Request schema for listing Slack team channels with various filtering options."
      }
    },
    {
      "name": "SLACKBOT_LIST_ALL_TEAM_USERS_WITH_PAGINATION",
      "description": "DEPRECATED: Retrieves a paginated list of all users in a Slack workspace. Use `list_all_users` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListAllUsersRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 1,
            "examples": [
              "20",
              "100",
              "200"
            ],
            "description": "Maximum number of items to return per page; fewer may be returned if the end of the list is reached. Recommended to set a value (e.g., 100) as Slack may error for large workspaces if omitted."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0STM=",
              "dXNlcjpVMDYxREk0STQ="
            ],
            "description": "Pagination cursor for fetching subsequent pages. Set to `next_cursor` from a previous response's `response_metadata`. Omit for the first page."
          },
          "include_locale": {
            "type": "boolean",
            "title": "Include Locale",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include the `locale` field for each user. Defaults to `false`."
          }
        },
        "description": "Request schema for `ListAllUsers`."
      }
    },
    {
      "name": "SLACKBOT_LIST_ALL_USERS",
      "description": "Retrieves a paginated list of all users, including comprehensive details, profile information, status, and team memberships, in a Slack workspace; data may not be real-time.",
      "inputSchema": {
        "type": "object",
        "title": "ListAllUsersRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": 1,
            "examples": [
              "20",
              "100",
              "200"
            ],
            "description": "Maximum number of items to return per page; fewer may be returned if the end of the list is reached. Recommended to set a value (e.g., 100) as Slack may error for large workspaces if omitted."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0STM=",
              "dXNlcjpVMDYxREk0STQ="
            ],
            "description": "Pagination cursor for fetching subsequent pages. Set to `next_cursor` from a previous response's `response_metadata`. Omit for the first page."
          },
          "include_locale": {
            "type": "boolean",
            "title": "Include Locale",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include the `locale` field for each user. Defaults to `false`."
          }
        },
        "description": "Request schema for `ListAllUsers`."
      }
    },
    {
      "name": "SLACKBOT_LIST_ALL_USERS_IN_A_USER_GROUP",
      "description": "Retrieves a list of all user IDs within a specified Slack user group, with an option to include users from disabled groups.",
      "inputSchema": {
        "type": "object",
        "title": "ListAllUsersInAUserGroupRequest",
        "required": [
          "usergroup"
        ],
        "properties": {
          "usergroup": {
            "type": "string",
            "title": "Usergroup",
            "examples": [
              "S0604QSJC",
              "S123ABC456"
            ],
            "description": "The encoded ID of the User Group to list users from. This ID is an alphanumeric string."
          },
          "include_disabled": {
            "type": "boolean",
            "title": "Include Disabled",
            "description": "Set to `true` to include users from disabled user groups. If omitted, the default Slack API behavior for handling disabled groups (typically excluding them) will apply."
          }
        },
        "description": "Request schema for listing all users in a Slack user group."
      }
    },
    {
      "name": "SLACKBOT_LIST_CANVASES",
      "description": "Lists Slack Canvases with filtering by channel, user, timestamp, and page-based pagination. Uses Slack's files.list API with types=canvas filter.",
      "inputSchema": {
        "type": "object",
        "title": "ListCanvasesRequest",
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "default": 1,
            "minimum": 1,
            "description": "Page number for pagination (1-based)"
          },
          "user": {
            "type": "string",
            "title": "User",
            "default": null,
            "examples": [
              "U1234567890"
            ],
            "nullable": true,
            "description": "Optional user ID to filter canvases created by a specific user."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": 100,
            "maximum": 1000,
            "minimum": 1,
            "description": "Maximum number of canvases to return per page (1-1000)"
          },
          "ts_to": {
            "type": "string",
            "title": "Ts To",
            "default": null,
            "examples": [
              "123456789"
            ],
            "nullable": true,
            "description": "Filter canvases created before this timestamp (inclusive). Unix timestamp as string."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "default": null,
            "examples": [
              "C1234567890",
              "C9876543210"
            ],
            "nullable": true,
            "description": "Optional channel ID (e.g., 'C1234567890') to filter canvases. Must be a channel ID, not name."
          },
          "ts_from": {
            "type": "string",
            "title": "Ts From",
            "default": null,
            "examples": [
              "123456789"
            ],
            "nullable": true,
            "description": "Filter canvases created after this timestamp (inclusive). Unix timestamp as string."
          }
        }
      }
    },
    {
      "name": "SLACKBOT_LIST_CONVERSATIONS",
      "description": "List conversations (channels/DMs) accessible to a specified user (or the authenticated user if no user ID is provided), respecting shared membership for non-public channels.",
      "inputSchema": {
        "type": "object",
        "title": "ListAccessibleConversationsForAUserRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U123ABC456",
              "W012A3BCD"
            ],
            "description": "The ID of the user whose conversations will be listed. If not provided, conversations for the authenticated user are returned. Non-public channels are restricted to those where the calling user (authenticating user) shares membership."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "500",
              "1000"
            ],
            "description": "The maximum number of items to return per page. Must be an integer, typically between 1 and 1000 (e.g., 100). If omitted, the API's default limit (often 100) applies. Fewer items than the limit may be returned."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "examples": [
              "public_channel,private_channel",
              "im,mpim",
              "public_channel"
            ],
            "description": "A comma-separated list of conversation types to include. Valid types are `public_channel`, `private_channel`, `mpim` (multi-person direct message), and `im` (direct message). If omitted, all types are included."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0Nlc=",
              "bmV4dF90czoxNTEyMDg1ODYxMDAwNTQz"
            ],
            "description": "Pagination cursor for retrieving the next set of results. Obtain this from the `next_cursor` field in a previous response's `response_metadata`. If omitted, the first page is fetched."
          },
          "exclude_archived": {
            "type": "boolean",
            "title": "Exclude Archived",
            "examples": [
              "true",
              "false"
            ],
            "description": "Set to `true` to exclude archived channels from the list. If `false` or omitted, archived channels are typically included (the API's default behavior for omission will apply, usually including them)."
          }
        },
        "description": "Request model for listing conversations accessible to a user, with options for pagination and filtering."
      }
    },
    {
      "name": "SLACKBOT_LIST_FILES_WITH_FILTERS_IN_SLACK",
      "description": "Lists files and their metadata within a Slack workspace, filterable by user, channel, timestamp, or type; this action returns metadata only, not file content.",
      "inputSchema": {
        "type": "object",
        "title": "ListFilesWithFiltersInSlackRequest",
        "properties": {
          "page": {
            "type": "string",
            "title": "Page",
            "examples": [
              "1",
              "2"
            ],
            "description": "Specifies the page number of the results to retrieve when paginating. Default is 1."
          },
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "W1234567890",
              "U0abcdef0"
            ],
            "description": "Filter files created by a single user. Provide the Slack User ID."
          },
          "count": {
            "type": "string",
            "title": "Count",
            "examples": [
              "100",
              "50",
              "1000"
            ],
            "description": "Specifies the number of files to return per page. Default is 100, maximum is 1000."
          },
          "ts_to": {
            "type": "integer",
            "title": "Ts To",
            "examples": [
              "1678972800"
            ],
            "description": "Filter files created before this Unix timestamp (inclusive)."
          },
          "types": {
            "type": "string",
            "title": "Types",
            "examples": [
              "images",
              "pdfs",
              "images,pdfs",
              "all",
              "spaces,snippets"
            ],
            "description": "Filter files by types (comma-separated: 'images,pdfs'). Default 'all' for all types. Common: `all`, `spaces` (posts), `snippets`, `images`, `gdocs`, `zips`, `pdfs`."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0abcdef0"
            ],
            "description": "Filter files appearing in a specific channel, indicated by its Slack Channel ID."
          },
          "ts_from": {
            "type": "integer",
            "title": "Ts From",
            "examples": [
              "1678886400"
            ],
            "description": "Filter files created after this Unix timestamp (inclusive)."
          },
          "show_files_hidden_by_limit": {
            "type": "boolean",
            "title": "Show Files Hidden By Limit",
            "examples": [
              true,
              false
            ],
            "description": "Show truncated file info for files hidden due to being too old or if the team owning the file is over the storage limit."
          }
        },
        "description": "Request schema for `ListFilesWithFiltersInSlack`"
      }
    },
    {
      "name": "SLACKBOT_LIST_REMINDERS",
      "description": "Lists all reminders with their details for the authenticated Slack user; returns an empty list if no reminders exist.",
      "inputSchema": {
        "type": "object",
        "title": "ListRemindersRequest",
        "properties": {},
        "description": "Request schema for `ListReminders`"
      }
    },
    {
      "name": "SLACKBOT_LIST_REMOTE_FILES",
      "description": "Retrieve information about a team's remote files.",
      "inputSchema": {
        "type": "object",
        "title": "ListRemoteFilesRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              20
            ],
            "description": "The maximum number of items to return."
          },
          "ts_to": {
            "type": "number",
            "title": "Ts To",
            "examples": [
              123456789.012345
            ],
            "description": "Filter files created before this timestamp (inclusive)."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZUVDI="
            ],
            "description": "Paginate through collections of data by setting the cursor parameter to a next_cursor attribute returned by a previous request's response_metadata. Default value fetches the first 'page' of the collection. See pagination for more detail."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "Filter files appearing in a specific channel, indicated by its ID."
          },
          "ts_from": {
            "type": "number",
            "title": "Ts From",
            "examples": [
              123456789.012345
            ],
            "description": "Filter files created after this timestamp (inclusive)."
          }
        },
        "description": "Request schema for `ListRemoteFiles`"
      }
    },
    {
      "name": "SLACKBOT_LIST_SCHEDULED_MESSAGES",
      "description": "Retrieves a list of pending (not yet delivered) messages scheduled in a specific Slack channel, or across all accessible channels if no channel ID is provided, optionally filtered by time and paginated.",
      "inputSchema": {
        "type": "object",
        "title": "ListScheduledMessagesRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "50"
            ],
            "description": "Maximum messages per page (1-1000). Defaults to 100."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0STM=",
              "bmV4dF9wYWdlX2N1cnNvcg=="
            ],
            "description": "Pagination cursor from `response_metadata.next_cursor` of a previous response. Omit for the first page."
          },
          "latest": {
            "type": "string",
            "title": "Latest",
            "default": null,
            "examples": [
              "1678886400.000000",
              "1678972800.000000"
            ],
            "nullable": true,
            "description": "Latest UNIX timestamp (exclusive) for messages. Defaults to the current time if omitted."
          },
          "oldest": {
            "type": "string",
            "title": "Oldest",
            "default": null,
            "examples": [
              "1678800000.000000",
              "1678880000.000000"
            ],
            "nullable": true,
            "description": "Earliest UNIX timestamp (inclusive) for messages. Defaults to 0 if omitted."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "ID or name of the channel (public, private, or DM) to list messages for. If omitted, lists for all accessible channels in the workspace."
          }
        },
        "description": "Request schema for listing scheduled messages in a channel or workspace."
      }
    },
    {
      "name": "SLACKBOT_LIST_SCHEDULED_MESSAGES_IN_A_CHANNEL",
      "description": "DEPRECATED: Retrieves a list of pending (not yet delivered) messages scheduled in a specific Slack channel. Use `list_scheduled_messages` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListScheduledMessagesRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "50"
            ],
            "description": "Maximum messages per page (1-1000). Defaults to 100."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxREk0STM=",
              "bmV4dF9wYWdlX2N1cnNvcg=="
            ],
            "description": "Pagination cursor from `response_metadata.next_cursor` of a previous response. Omit for the first page."
          },
          "latest": {
            "type": "string",
            "title": "Latest",
            "default": null,
            "examples": [
              "1678886400.000000",
              "1678972800.000000"
            ],
            "nullable": true,
            "description": "Latest UNIX timestamp (exclusive) for messages. Defaults to the current time if omitted."
          },
          "oldest": {
            "type": "string",
            "title": "Oldest",
            "default": null,
            "examples": [
              "1678800000.000000",
              "1678880000.000000"
            ],
            "nullable": true,
            "description": "Earliest UNIX timestamp (inclusive) for messages. Defaults to 0 if omitted."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "ID or name of the channel (public, private, or DM) to list messages for. If omitted, lists for all accessible channels in the workspace."
          }
        },
        "description": "Request schema for listing scheduled messages in a channel or workspace."
      }
    },
    {
      "name": "SLACKBOT_LISTS_PINNED_ITEMS_IN_A_CHANNEL",
      "description": "Retrieves all messages and files pinned to a specified channel; the caller must have access to this channel.",
      "inputSchema": {
        "type": "object",
        "title": "ListsPinnedItemsInAChannelRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0123456789",
              "D0123456789"
            ],
            "description": "The ID of the channel to retrieve pinned items from. This can be a public channel ID, private group ID, or direct message channel ID."
          }
        },
        "description": "Request schema for `ListsPinnedItemsInAChannel`"
      }
    },
    {
      "name": "SLACKBOT_LIST_S_REMOTE_FILES_WITH_FILTERS",
      "description": "DEPRECATED: Retrieve information about a team's remote files. Use `list_remote_files` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListRemoteFilesRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              20
            ],
            "description": "The maximum number of items to return."
          },
          "ts_to": {
            "type": "number",
            "title": "Ts To",
            "examples": [
              123456789.012345
            ],
            "description": "Filter files created before this timestamp (inclusive)."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZUVDI="
            ],
            "description": "Paginate through collections of data by setting the cursor parameter to a next_cursor attribute returned by a previous request's response_metadata. Default value fetches the first 'page' of the collection. See pagination for more detail."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "Filter files appearing in a specific channel, indicated by its ID."
          },
          "ts_from": {
            "type": "number",
            "title": "Ts From",
            "examples": [
              123456789.012345
            ],
            "description": "Filter files created after this timestamp (inclusive)."
          }
        },
        "description": "Request schema for `ListRemoteFiles`"
      }
    },
    {
      "name": "SLACKBOT_LIST_STARRED_ITEMS",
      "description": "Lists items starred by a user.",
      "inputSchema": {
        "type": "object",
        "title": "ListStarredItemsRequest",
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "default": null,
            "examples": [
              2
            ],
            "nullable": true,
            "description": "Page number of results to return."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": null,
            "examples": [
              20
            ],
            "nullable": true,
            "description": "Number of items to return per page."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": null,
            "examples": [
              20
            ],
            "nullable": true,
            "description": "The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "default": null,
            "examples": [
              "dXNlcjpVMDYxTkZUVDI="
            ],
            "nullable": true,
            "description": "Parameter for pagination. Set cursor to the next_cursor attribute returned by the previous request's response_metadata."
          }
        },
        "description": "Request schema for `ListStarredItems`"
      }
    },
    {
      "name": "SLACKBOT_LISTS_USER_S_STARRED_ITEMS_WITH_PAGINATION",
      "description": "DEPRECATED: Lists items starred by a user. Use `list_starred_items` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListStarredItemsRequest",
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "default": null,
            "examples": [
              2
            ],
            "nullable": true,
            "description": "Page number of results to return."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": null,
            "examples": [
              20
            ],
            "nullable": true,
            "description": "Number of items to return per page."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": null,
            "examples": [
              20
            ],
            "nullable": true,
            "description": "The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "default": null,
            "examples": [
              "dXNlcjpVMDYxTkZUVDI="
            ],
            "nullable": true,
            "description": "Parameter for pagination. Set cursor to the next_cursor attribute returned by the previous request's response_metadata."
          }
        },
        "description": "Request schema for `ListStarredItems`"
      }
    },
    {
      "name": "SLACKBOT_LIST_TEAM_CUSTOM_EMOJIS",
      "description": "Retrieves all custom emojis for the Slack workspace (image URLs or aliases), not standard Unicode emojis; does not include usage statistics or creation dates.",
      "inputSchema": {
        "type": "object",
        "title": "ListTeamCustomEmojisRequest",
        "properties": {},
        "description": "Request model for the `ListTeamCustomEmojis` action. This action does not require any request parameters."
      }
    },
    {
      "name": "SLACKBOT_LIST_USER_GROUPS_FOR_TEAM_WITH_OPTIONS",
      "description": "Lists user groups in a Slack workspace, including user-created and default groups; results for large workspaces may be paginated.",
      "inputSchema": {
        "type": "object",
        "title": "ListUserGroupsForTeamWithOptionsRequest",
        "properties": {
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include the number of users in each user group. Defaults to false."
          },
          "include_users": {
            "type": "boolean",
            "title": "Include Users",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include the list of user IDs for each user group. Defaults to false."
          },
          "include_disabled": {
            "type": "boolean",
            "title": "Include Disabled",
            "examples": [
              "true",
              "false"
            ],
            "description": "Include disabled user groups in the results. Defaults to false."
          }
        },
        "description": "Request model for listing user groups in a Slack team, providing options to customize the retrieved information."
      }
    },
    {
      "name": "SLACKBOT_LIST_USER_REACTIONS",
      "description": "Lists all reactions added by a specific user to messages, files, or file comments in Slack, useful for engagement analysis when the item content itself is not required.",
      "inputSchema": {
        "type": "object",
        "title": "ListUserReactionsRequest",
        "properties": {
          "full": {
            "type": "boolean",
            "title": "Full",
            "description": "If true, return the complete reaction list, which may include reactions to deleted items."
          },
          "page": {
            "type": "integer",
            "title": "Page",
            "examples": [
              "1"
            ],
            "description": "Page number of results to return."
          },
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U012A3CDEFG"
            ],
            "description": "Reactions made by this user. Defaults to the authed user."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "examples": [
              "20"
            ],
            "description": "Number of items to return per page."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100"
            ],
            "description": "Maximum number of items to return; fewer items may be returned. Use with cursor-based pagination."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMDYxTkZ0NUI="
            ],
            "description": "Pagination cursor. Set to `next_cursor` from a previous response's `response_metadata`. See Slack API pagination documentation for details."
          }
        },
        "description": "Request schema for `ListUserReactions`"
      }
    },
    {
      "name": "SLACKBOT_LIST_USER_REMINDERS_WITH_DETAILS",
      "description": "DEPRECATED: Lists all reminders with their details for the authenticated Slack user. Use `list_reminders` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ListRemindersRequest",
        "properties": {},
        "description": "Request schema for `ListReminders`"
      }
    },
    {
      "name": "SLACKBOT_LIST_WORKSPACE_USERS",
      "description": "Retrieves a paginated list of admin users for a specified Slack workspace.",
      "inputSchema": {
        "type": "object",
        "title": "ListWorkspaceUsersRequest",
        "required": [
          "team_id"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "20",
              "50",
              "100"
            ],
            "description": "The maximum number of admin users to retrieve per page. Must be a positive integer. If not specified, a default limit set by Slack will apply."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcjpVMEc5V0ZYTlo="
            ],
            "description": "Pagination cursor for retrieving the next page of results. Pass the `next_cursor` value returned from a previous request to fetch subsequent items. If omitted, the first page is retrieved."
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "examples": [
              "T123456789"
            ],
            "description": "The ID of the Slack workspace (e.g., `T123456789`) from which to list admin users."
          }
        },
        "description": "Request schema for listing admin users in a Slack workspace."
      }
    },
    {
      "name": "SLACKBOT_LOOKUP_CANVAS_SECTIONS",
      "description": "Looks up section IDs in a Slack Canvas for use with targeted edit operations. Section IDs are needed for insert_after, insert_before, delete, and section-specific replace operations.",
      "inputSchema": {
        "type": "object",
        "title": "LookupCanvasSectionsRequest",
        "required": [
          "canvas_id",
          "criteria"
        ],
        "properties": {
          "criteria": {
            "type": "object",
            "title": "Criteria",
            "examples": [
              {
                "contains_text": "grocery"
              },
              {
                "contains_text": "Roadmap"
              },
              {
                "contains_text": "Task"
              }
            ],
            "description": "Search criteria to find sections. Use 'contains_text' to search for text within sections. Returns section IDs that match the criteria.",
            "additionalProperties": true
          },
          "canvas_id": {
            "type": "string",
            "title": "Canvas Id",
            "examples": [
              "F01234ABCDE"
            ],
            "description": "The unique identifier of the canvas to lookup sections in"
          }
        }
      }
    },
    {
      "name": "SLACKBOT_MANUALLY_SET_USER_PRESENCE",
      "description": "Manually sets a user's Slack presence, overriding automatic detection; this setting persists across connections but can be overridden by user actions or Slack's auto-away (e.g., after 10 mins of inactivity).",
      "inputSchema": {
        "type": "object",
        "title": "ManuallySetUserPresenceRequest",
        "required": [
          "presence"
        ],
        "properties": {
          "presence": {
            "type": "string",
            "title": "Presence",
            "examples": [
              "auto",
              "away"
            ],
            "description": "The presence state to set for the user. Valid values are 'auto' (Slack determines presence based on activity) or 'away' (sets presence to away)."
          }
        },
        "description": "Request schema for ManuallySetUserPresence, allowing manual setting of a user's presence."
      }
    },
    {
      "name": "SLACKBOT_MARK_REMINDER_AS_COMPLETE",
      "description": "Marks a specific Slack reminder as complete using its `reminder` ID; **DEPRECATED**: This Slack API endpoint ('reminders.complete') was deprecated in March 2023 and is not recommended for new applications.",
      "inputSchema": {
        "type": "object",
        "title": "MarkReminderAsCompleteRequest",
        "properties": {
          "reminder": {
            "type": "string",
            "title": "Reminder",
            "default": null,
            "examples": [
              "R0123456789"
            ],
            "nullable": true,
            "description": "The unique identifier of the Slack reminder to be marked as complete. This ID is typically obtained when a reminder is created or listed."
          }
        },
        "description": "Request model for marking a specific Slack reminder as complete."
      }
    },
    {
      "name": "SLACKBOT_OPEN_DM",
      "description": "Opens or resumes a Slack direct message (DM) or multi-person direct message (MPIM) by providing either user IDs or an existing channel ID.",
      "inputSchema": {
        "type": "object",
        "title": "OpenOrResumeDirectOrMultiPersonMessagesRequest",
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U0123456789",
              "U0123456789,U9876543210"
            ],
            "description": "Comma-separated list of user IDs (1 for a DM, or 2-8 for an MPIM) to open/resume a conversation. Order is preserved for MPIMs. Do not use if `channel` is provided."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "D0123456789",
              "general"
            ],
            "description": "ID or name of an existing DM or MPIM channel to open/resume. Do not use if `users` is provided."
          },
          "return_im": {
            "type": "boolean",
            "title": "Return Im",
            "description": "If `true`, returns the full DM channel object. Applies only when opening a DM via a single user ID in `users` (not with `channel`)."
          }
        },
        "description": "Request schema for `OpenOrResumeDirectOrMultiPersonMessages`"
      }
    },
    {
      "name": "SLACKBOT_OPEN_OR_RESUME_DIRECT_OR_MULTI_PERSON_MESSAGES",
      "description": "DEPRECATED: Opens or resumes a Slack direct message (DM) or multi-person direct message (MPIM). Use `open_dm` instead.",
      "inputSchema": {
        "type": "object",
        "title": "OpenOrResumeDirectOrMultiPersonMessagesRequest",
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U0123456789",
              "U0123456789,U9876543210"
            ],
            "description": "Comma-separated list of user IDs (1 for a DM, or 2-8 for an MPIM) to open/resume a conversation. Order is preserved for MPIMs. Do not use if `channel` is provided."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "D0123456789",
              "general"
            ],
            "description": "ID or name of an existing DM or MPIM channel to open/resume. Do not use if `users` is provided."
          },
          "return_im": {
            "type": "boolean",
            "title": "Return Im",
            "description": "If `true`, returns the full DM channel object. Applies only when opening a DM via a single user ID in `users` (not with `channel`)."
          }
        },
        "description": "Request schema for `OpenOrResumeDirectOrMultiPersonMessages`"
      }
    },
    {
      "name": "SLACKBOT_PINS_AN_ITEM_TO_A_CHANNEL",
      "description": "Pins a message to a specified Slack channel; the message must not already be pinned.",
      "inputSchema": {
        "type": "object",
        "title": "PinsAnItemToAChannelRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "The ID of the channel where the message will be pinned."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1624464000.000200"
            ],
            "description": "Timestamp of the message to pin, in 'epoch_time.microseconds' format (e.g., '1624464000.000200'). If not provided, the most recent message in the channel will be pinned."
          }
        },
        "description": "Request schema for `PinsAnItemToAChannel`"
      }
    },
    {
      "name": "SLACKBOT_REGISTER_CALL_PARTICIPANTS_REMOVAL",
      "description": "DEPRECATED: Registers participants removed from a Slack call. Use `remove_call_participants` instead.",
      "inputSchema": {
        "type": "object",
        "title": "RemoveCallParticipantsRequest",
        "required": [
          "id",
          "users"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123456789"
            ],
            "description": "ID of the call returned by the add method."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]",
              "[{\"slack_id\": \"U2ABC123\"}]"
            ],
            "description": "The list of users to remove as participants in the call. users is a JSON array with each user having a `slack_id` or `external_id`."
          }
        },
        "description": "Request schema for `RemoveCallParticipants`"
      }
    },
    {
      "name": "SLACKBOT_REGISTERS_A_NEW_CALL_WITH_PARTICIPANTS",
      "description": "DEPRECATED: Registers a new call in Slack using `calls.add` for third-party call integration. Use `start_call` instead.",
      "inputSchema": {
        "type": "object",
        "title": "StartCallRequest",
        "required": [
          "external_unique_id",
          "join_url"
        ],
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Project Alpha Sync",
              "Q3 Planning Session"
            ],
            "description": "The name or title for the call. This will be displayed in Slack to identify the call."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "'''[{\"slack_id\": \"U012A3BCD4E\"}, {\"external_id\": \"participant1@example.com\", \"slack_id\": \"U012A3BCD4F\"}]'''",
              "'''[{\"slack_id\": \"W012A3CDE\"}]'''",
              "'''[{\"external_id\": \"meeting-user-789\"}]'''"
            ],
            "description": "A JSON string representing an array of user objects to be registered as participants in the call. Each user object in the array should define a participant using their `slack_id` (Slack User ID) and/or an `external_id` (an identifier from the third-party application, unique to that user within that application). For instance: `'''[{\"slack_id\": \"U012A3BCD4E\"}, {\"external_id\": \"user-xyz@example.com\", \"slack_id\": \"U012A3BCD4F\"}]'''`."
          },
          "join_url": {
            "type": "string",
            "title": "Join Url",
            "examples": [
              "https://thirdparty.call/join/meeting123",
              "https://example.com/s/abc-123-def"
            ],
            "description": "The URL required for a client to join the call (e.g., a web join link). This field is mandatory."
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "examples": [
              "U012A3BCD4E",
              "U061F7AUR"
            ],
            "description": "Slack user ID of the creator; optional (defaults to authenticated user) if using a user token, otherwise required."
          },
          "date_start": {
            "type": "integer",
            "title": "Date Start",
            "examples": [
              "1678886400",
              "1700000000"
            ],
            "description": "The start time of the call, specified as a UTC UNIX timestamp in seconds. For example, `1678886400` corresponds to March 15, 2023, at 12:00 PM UTC."
          },
          "external_unique_id": {
            "type": "string",
            "title": "External Unique Id",
            "examples": [
              "v=abcdef123456",
              "call-ext-98765uuid-from-provider"
            ],
            "description": "A unique identifier for the call, supplied by the third-party call provider. This ID must be unique across all calls from that specific service. This field is required."
          },
          "external_display_id": {
            "type": "string",
            "title": "External Display Id",
            "examples": [
              "Meeting H.323",
              "CONF-7890"
            ],
            "description": "An optional, human-readable identifier for the call, supplied by the third-party call provider. If provided, this ID will be displayed in the Slack call object interface."
          },
          "desktop_app_join_url": {
            "type": "string",
            "title": "Desktop App Join Url",
            "examples": [
              "your-app-protocol://call/12345",
              "zoomus://zoom.us/join?confno=1234567890"
            ],
            "description": "An optional URL that, when provided, allows Slack clients to attempt to directly launch the third-party call application. This is typically a deep link URI for the specific application."
          }
        },
        "description": "Request payload for registering a new call with participants in Slack."
      }
    },
    {
      "name": "SLACKBOT_REGISTERS_NEW_CALL_PARTICIPANTS",
      "description": "DEPRECATED: Registers new participants added to a Slack call. Use `add_call_participants` instead.",
      "inputSchema": {
        "type": "object",
        "title": "AddCallParticipantsRequest",
        "required": [
          "id",
          "users"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123456789"
            ],
            "description": "ID of the call returned by the add method."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]",
              "[{\"slack_id\": \"U2ABC123\"}]"
            ],
            "description": "The list of users to add as participants in the call. users is a JSON array (formatted as a string) containing information for each user. Each element should include both a `slack_id` and optionally an `external_id`. For example: `[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]`."
          }
        },
        "description": "Request schema for `AddCallParticipants`"
      }
    },
    {
      "name": "SLACKBOT_REMOVE_A_REMOTE_FILE",
      "description": "Removes the Slack reference to an external file (which must have been previously added via the remote files API), specified by either its `external_id` or `file` ID (one of which is required), without deleting the actual external file.",
      "inputSchema": {
        "type": "object",
        "title": "RemoveARemoteFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F0123ABCDEF",
              "F9876ZYXWVU"
            ],
            "description": "Slack-specific file ID."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "my-unique-file-guid-12345",
              "doc-abc-external-id"
            ],
            "description": "Creator-defined, globally unique ID (GUID) for the file."
          }
        },
        "description": "Request schema for `RemoveARemoteFile`"
      }
    },
    {
      "name": "SLACKBOT_REMOVE_A_STAR_FROM_AN_ITEM",
      "description": "Removes a star from a previously starred Slack item (message, file, file comment, channel, group, or DM), requiring identification via `file`, `file_comment`, `channel` (for channel/group/DM), or both `channel` and `timestamp` (for a message).",
      "inputSchema": {
        "type": "object",
        "title": "RemoveAStarFromAnItemRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F1234567890"
            ],
            "description": "ID of the file to unstar."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321"
            ],
            "description": "ID of the item (channel, private group, DM) or the message's channel (if `timestamp` is also provided)."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1629883200.000100",
              "1503435956.000247"
            ],
            "description": "Timestamp of the message to unstar; requires `channel`."
          },
          "file_comment": {
            "type": "string",
            "title": "File Comment",
            "examples": [
              "Fc1234567890"
            ],
            "description": "ID of the file comment to unstar."
          }
        },
        "description": "Request schema for removing a star from an item in Slack."
      }
    },
    {
      "name": "SLACKBOT_REMOVE_A_USER_FROM_A_CONVERSATION",
      "description": "Removes a specified user from a Slack conversation (channel); the caller must have permissions to remove users and cannot remove themselves using this action.",
      "inputSchema": {
        "type": "object",
        "title": "RemoveAUserFromAConversationRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U012A3BCD4E",
              "W1234567890"
            ],
            "description": "The ID of the user to be removed from the conversation."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C012AB3CD4E",
              "G1234567890"
            ],
            "description": "ID of the conversation (channel) to remove the user from."
          }
        },
        "description": "Request schema for `RemoveAUserFromAConversation`"
      }
    },
    {
      "name": "SLACKBOT_REMOVE_CALL_PARTICIPANTS",
      "description": "Registers participants removed from a Slack call.",
      "inputSchema": {
        "type": "object",
        "title": "RemoveCallParticipantsRequest",
        "required": [
          "id",
          "users"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123456789"
            ],
            "description": "ID of the call returned by the add method."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "[{\"slack_id\": \"U1H77\", \"external_id\": \"ext-id\"}]",
              "[{\"slack_id\": \"U2ABC123\"}]"
            ],
            "description": "The list of users to remove as participants in the call. users is a JSON array with each user having a `slack_id` or `external_id`."
          }
        },
        "description": "Request schema for `RemoveCallParticipants`"
      }
    },
    {
      "name": "SLACKBOT_REMOVE_REACTION_FROM_ITEM",
      "description": "Removes an emoji reaction from a message, file, or file comment in Slack.",
      "inputSchema": {
        "type": "object",
        "title": "RemoveReactionFromItemRequest",
        "required": [
          "name"
        ],
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "description": "ID of the file to remove the reaction from."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "thumbsup",
              "smile",
              "robot_face"
            ],
            "description": "Name of the emoji reaction to remove (e.g., 'thumbsup'), without colons."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "description": "Channel ID of the message. Required if `timestamp` is provided."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "description": "Timestamp of the message. Required if `channel` is provided."
          },
          "file_comment": {
            "type": "string",
            "title": "File Comment",
            "description": "ID of the file comment to remove the reaction from."
          }
        },
        "description": "Request schema for `RemoveReactionFromItem`"
      }
    },
    {
      "name": "SLACKBOT_RENAME_A_CHANNEL",
      "description": "Renames a public or private Slack channel; for Enterprise Grid workspaces, the user must be a Workspace Admin or Channel Manager.",
      "inputSchema": {
        "type": "object",
        "title": "RenameASlackChannelRequest",
        "required": [
          "channel_id",
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "project-alpha-bugs",
              "team-marketing-campaign"
            ],
            "description": "The new name for the channel. Channel names can be up to 80 characters long and may include lowercase letters, numbers, hyphens, and underscores. They cannot contain spaces or periods."
          },
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C012AB3CD"
            ],
            "description": "The ID of the channel to rename."
          }
        },
        "description": "Request schema for `RenameASlackChannel`"
      }
    },
    {
      "name": "SLACKBOT_RENAME_A_CONVERSATION",
      "description": "Renames a Slack channel, automatically adjusting the new name to meet naming conventions (e.g., converting to lowercase), which may affect integrations using the old name.",
      "inputSchema": {
        "type": "object",
        "title": "RenameAConversationRequest",
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "new-channel-name"
            ],
            "description": "New name for the conversation. Must be 80 characters or less and contain only lowercase letters, numbers, hyphens, and underscores."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C012AB3CD"
            ],
            "description": "ID of the conversation (channel) to rename."
          }
        },
        "description": "Request schema for `RenameAConversation`"
      }
    },
    {
      "name": "SLACKBOT_RENAME_AN_EMOJI",
      "description": "Renames an existing custom emoji in a Slack workspace, updating all its instances.",
      "inputSchema": {
        "type": "object",
        "title": "RenameAnEmojiRequest",
        "required": [
          "name",
          "new_name",
          "token"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "current_emoji_name",
              "old_face"
            ],
            "description": "Current name of the custom emoji to be renamed. Colons (e.g., `:current_emoji:`) are optional."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token."
          },
          "new_name": {
            "type": "string",
            "title": "New Name",
            "examples": [
              "new_emoji_name",
              "updated_icon"
            ],
            "description": "Desired new name for the custom emoji. Must be unique within the workspace and adhere to Slack's emoji naming conventions."
          }
        },
        "description": "Request schema for `RenameAnEmoji`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_A_USER_S_IDENTITY_DETAILS",
      "description": "Retrieves the authenticated user's and their team's identity, with details varying based on OAuth scopes (e.g., `identity.basic`, `identity.email`, `identity.avatar`).",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveAUserSIdentityDetailsRequest",
        "properties": {},
        "description": "User identification is based on the provided authentication token; no request body parameters are needed."
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_CALL_INFORMATION",
      "description": "Retrieves a point-in-time snapshot of a specific Slack call's information.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveCallInformationRequest",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R1234567890"
            ],
            "description": "Unique identifier of the Slack call for which to retrieve information. This ID is typically returned when a call is initiated (e.g., by the `calls.add` method)."
          }
        },
        "description": "Request model for retrieving information about a specific Slack call."
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_CONVERSATION_INFORMATION",
      "description": "Retrieves metadata for a Slack conversation by ID (e.g., name, purpose, creation date, with options for member count/locale), excluding message content; requires a valid channel ID.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveConversationInformationRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "D0G9QPYHR",
              "G01234567"
            ],
            "description": "The ID of the conversation (channel, direct message, or multi-person direct message) to retrieve information for."
          },
          "include_locale": {
            "type": "boolean",
            "title": "Include Locale",
            "description": "If true, the response will include the locale setting for the conversation. Defaults to false."
          },
          "include_num_members": {
            "type": "boolean",
            "title": "Include Num Members",
            "description": "If true, the response will include the number of members in the conversation. Defaults to false."
          }
        },
        "description": "Request schema for `RetrieveConversationInformation`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_CONVERSATION_MEMBERS_LIST",
      "description": "Retrieves a paginated list of active member IDs for a specified Slack public channel, private channel, direct message (DM), or multi-person direct message (MPIM).",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveConversationMembersListRequest",
        "properties": {
          "limit": {
            "type": "integer",
            "title": "Limit",
            "examples": [
              "100",
              "200"
            ],
            "description": "The maximum number of members to return per page. Fewer items may be returned than the requested limit, even if more members exist and the end of the list hasn't been reached."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "examples": [
              "dXNlcj1VMEc5V0ZYTlo=",
              "bmV4dF90czoxNTEyMDg1ODYxMDAwNTZa"
            ],
            "description": "Pagination cursor value for fetching specific pages of results. To retrieve the next page, provide the `next_cursor` value obtained from the `response_metadata` of the previous API call. If omitted or empty, the first page of members is fetched. For more details on pagination, refer to Slack API documentation."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321",
              "D12345ABCDE"
            ],
            "description": "ID of the conversation (public channel, private channel, direct message, or multi-person direct message) for which to retrieve the member list. Public channel IDs typically start with 'C', private channels or multi-person direct messages (MPIMs) with 'G', and direct messages (DMs) with 'D'."
          }
        },
        "description": "Request schema for `RetrieveConversationMembersList`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_CURRENT_USER_DND_STATUS",
      "description": "Retrieves a Slack user's current Do Not Disturb (DND) status to determine their availability before interaction; any specified user ID must be a valid Slack user ID.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveCurrentUserDndStatusRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "default": null,
            "examples": [
              "U012ABCDEF",
              "W12345678"
            ],
            "nullable": true,
            "description": "User ID to fetch DND status for. If not provided, fetches the DND status for the authenticated user."
          }
        },
        "description": "Request schema for retrieving the current Do Not Disturb (DND) status of a user."
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_DETAILED_INFORMATION_ABOUT_A_FILE",
      "description": "Retrieves detailed metadata and paginated comments for a specific Slack file ID; does not download file content.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveDetailedInformationAboutAFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "default": null,
            "examples": [
              "F123ABCDEF0"
            ],
            "nullable": true,
            "description": "ID of the file to retrieve information for. This is a required field."
          },
          "page": {
            "type": "string",
            "title": "Page",
            "default": null,
            "examples": [
              "1",
              "3"
            ],
            "nullable": true,
            "description": "Page number of comment results to retrieve. Expects a string representing an integer (e.g., '2'). Used for comment pagination. Slack's default is 1 if not provided. `cursor`-based pagination is generally preferred."
          },
          "count": {
            "type": "string",
            "title": "Count",
            "default": null,
            "examples": [
              "20",
              "100"
            ],
            "nullable": true,
            "description": "Number of comments to retrieve per page. Expects a string representing an integer (e.g., '20'). Used for comment pagination. Slack's default is 100 if not provided."
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "default": null,
            "examples": [
              "10",
              "50"
            ],
            "nullable": true,
            "description": "The maximum number of comments to retrieve. This is an upper limit, not a guarantee of how many will be returned. Primarily used for comment pagination."
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "default": null,
            "examples": [
              "dXNlcjpVMDYxRkExNDIK",
              "bmV4dF90czoxNTEyMDg2NDE1MDAwOTc2"
            ],
            "nullable": true,
            "description": "Pagination cursor for retrieving comments. Set to `next_cursor` from a previous response's `response_metadata` to fetch the next page of comments. Essential for navigating through large sets of comments. See [pagination](https://slack.dev) for more details."
          }
        },
        "description": "Request model for retrieving detailed information about a specific file, including parameters for comment pagination."
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_DETAILED_USER_INFORMATION",
      "description": "Retrieves comprehensive information for a valid Slack user ID, excluding message history and channel memberships.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveDetailedUserInformationRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "default": null,
            "examples": [
              "U012ABCDEF",
              "W021XYZABC"
            ],
            "nullable": true,
            "description": "The ID of the user to retrieve information for."
          },
          "include_locale": {
            "type": "boolean",
            "title": "Include Locale",
            "default": null,
            "nullable": true,
            "description": "Set to `true` to include the user's locale (e.g., `en-US`) in the response. Defaults to `false`."
          }
        },
        "description": "Request schema for `RetrieveDetailedUserInformation`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_MESSAGE_PERMALINK_URL",
      "description": "Retrieves a permalink URL for a specific message in a Slack channel or conversation; the permalink respects Slack's privacy settings.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveMessagePermalinkUrlRequest",
        "required": [
          "channel",
          "message_ts"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C012AB3CD",
              "G123456"
            ],
            "description": "The ID of the conversation or channel containing the message. This can be a public channel ID, a private channel ID, a direct message channel ID, or a multi-person direct message channel ID."
          },
          "message_ts": {
            "type": "string",
            "title": "Message Ts",
            "examples": [
              "1610144875.000600",
              "15712345.001500"
            ],
            "description": "A message's `ts` value (timestamp), uniquely identifying it within a channel. Example: '1610144875.000600'."
          }
        },
        "description": "Request schema for `RetrieveMessagePermalinkUrl`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_REMOTE_FILE_INFO_IN_SLACK",
      "description": "DEPRECATED: Retrieve information about a remote file added to Slack. Use `get_remote_file` instead.",
      "inputSchema": {
        "type": "object",
        "title": "GetRemoteFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F2147483862"
            ],
            "description": "Specify a file by providing its ID."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "123456"
            ],
            "description": "Creator defined GUID for the file."
          }
        },
        "description": "Request schema for `GetRemoteFile`"
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_TEAM_PROFILE_DETAILS",
      "description": "Retrieves all profile field definitions for a Slack team, optionally filtered by visibility, to understand the team's profile structure.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveTeamProfileDetailsRequest",
        "properties": {
          "visibility": {
            "type": "string",
            "title": "Visibility",
            "default": null,
            "examples": [
              "all",
              "visible",
              "hidden"
            ],
            "nullable": true,
            "description": "Filters profile fields by visibility. Use 'all' for all fields (default if unspecified), 'visible' for fields where 'is_hidden' is false/unset, or 'hidden' for fields where 'is_hidden' is true."
          }
        },
        "description": "Request schema to fetch team profile settings."
      }
    },
    {
      "name": "SLACKBOT_RETRIEVE_USER_PROFILE_INFORMATION",
      "description": "Retrieves profile information for a specified Slack user (defaults to the authenticated user if `user` ID is omitted); a provided `user` ID must be valid.",
      "inputSchema": {
        "type": "object",
        "title": "RetrieveUserProfileInformationRequest",
        "properties": {
          "user": {
            "type": "string",
            "title": "User",
            "default": null,
            "examples": [
              "U012A3CDE",
              "W1234567890"
            ],
            "nullable": true,
            "description": "User ID to retrieve profile information for; defaults to the authenticated user."
          },
          "include_labels": {
            "type": "boolean",
            "title": "Include Labels",
            "default": null,
            "examples": [
              true,
              false
            ],
            "nullable": true,
            "description": "Include human-readable labels for custom profile fields. API defaults to false."
          }
        },
        "description": "Specifies the user and options for retrieving their profile."
      }
    },
    {
      "name": "SLACKBOT_REVERSE_A_CONVERSATION_S_ARCHIVAL_STATUS",
      "description": "DEPRECATED: Reverses conversation archival. Use `unarchive_channel` instead.",
      "inputSchema": {
        "type": "object",
        "title": "UnarchiveChannelRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "ID of conversation to unarchive"
          }
        },
        "description": "Request schema for `UnarchiveChannel`"
      }
    },
    {
      "name": "SLACKBOT_REVOKE_PUBLIC_SHARING_ACCESS_FOR_A_FILE",
      "description": "Revokes a Slack file's public URL, making it private; this is a no-op if not already public and is irreversible.",
      "inputSchema": {
        "type": "object",
        "title": "RevokePublicSharingAccessForAFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F123ABC456"
            ],
            "description": "The ID of the file for which to revoke the public URL. This unique identifier typically starts with 'F'."
          }
        },
        "description": "Request schema for `RevokePublicSharingAccessForAFile`"
      }
    },
    {
      "name": "SLACKBOT_SCHEDULE_MESSAGE",
      "description": "Schedules a message to a Slack channel, DM, or private group for a future time (`post_at`), requiring `text`, `blocks`, or `attachments` for content; scheduling is limited to 120 days in advance.",
      "inputSchema": {
        "type": "object",
        "title": "ScheduleMessageRequest",
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello, world!"
            ],
            "description": "This sends raw text only, use markdown_text field for formatting. Primary text of the message; formatting with `mrkdwn` applies. Required if `blocks` and `attachments` are not provided."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "none",
              "full"
            ],
            "description": "Message text treatment: `full` for special formatting, `none` otherwise (default). See Slack's `chat.postMessage` docs for options."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "[{\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"New Paid Time Off request from <example.com|Fred Enriquez>\"}}]"
            ],
            "description": "**DEPRECATED**: Use `markdown_text` field instead. JSON array of structured blocks as a URL-encoded string for message layout and design. Required if `text` and `attachments` are not provided."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "Post as the authenticated user, not a bot. Defaults to false. See Slack's `chat.postMessage` docs for authorship."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "#general",
              "U1234567890"
            ],
            "description": "Channel, private group, or DM channel ID (e.g., C1234567890) or name (e.g., #general) to send the message to."
          },
          "post_at": {
            "type": "string",
            "title": "Post At",
            "examples": [
              "1678886400"
            ],
            "description": "Unix EPOCH timestamp (integer seconds since 1970-01-01 00:00:00 UTC) for the future message send time."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "examples": [
              "1405894322.002768"
            ],
            "description": "Timestamp of the parent message for the scheduled message to be a thread reply. Must be float seconds (e.g., `1234567890.123456`)."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "description": "Pass true to automatically link channel names (e.g., #general) and usernames (e.g., @user)."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "[{\"color\": \"good\", \"text\": \"Yay! You did it!\", \"fields\": [{\"title\": \"Priority\", \"value\": \"High\", \"short\": false}]}]"
            ],
            "description": "JSON array of structured attachments as a URL-encoded string for rich content. Required if `text` and `blocks` are not provided."
          },
          "unfurl_links": {
            "type": "boolean",
            "title": "Unfurl Links",
            "description": "Pass false to disable automatic link unfurling. Defaults to true."
          },
          "unfurl_media": {
            "type": "boolean",
            "title": "Unfurl Media",
            "description": "Pass false to disable automatic media unfurling. Defaults to true."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Scheduled Reminder\n\nDon't forget about the **team meeting** tomorrow at *2 PM*!\n\n```\nZoom: https://zoom.us/meeting-id\n```",
              "## Weekly Report\n\n- **Tasks completed**: 12\n- *In progress*: 3\n- ~~Blocked~~: **Resolved**\n\n---\n\n**Due**: End of week"
            ],
            "description": "**PREFERRED**: Write your scheduled message in markdown for nicely formatted display. Supports headers (#), bold (**text**), italic (*text*), strikethrough (~~text~~), code (```), links ([text](url)), quotes (>), and dividers (---). Your message will be posted with beautiful formatting."
          },
          "reply_broadcast": {
            "type": "boolean",
            "title": "Reply Broadcast",
            "description": "With `thread_ts`, makes reply visible to all in channel, not just thread members. Defaults to `false`."
          }
        },
        "description": "Request schema for `ScheduleMessage`"
      }
    },
    {
      "name": "SLACKBOT_SCHEDULES_A_MESSAGE_TO_A_CHANNEL_AT_A_SPECIFIED_TIME",
      "description": "DEPRECATED: Schedules a message to a Slack channel, DM, or private group for a future time. Use `schedule_message` instead.",
      "inputSchema": {
        "type": "object",
        "title": "ScheduleMessageRequest",
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello, world!"
            ],
            "description": "This sends raw text only, use markdown_text field for formatting. Primary text of the message; formatting with `mrkdwn` applies. Required if `blocks` and `attachments` are not provided."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "none",
              "full"
            ],
            "description": "Message text treatment: `full` for special formatting, `none` otherwise (default). See Slack's `chat.postMessage` docs for options."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "[{\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"New Paid Time Off request from <example.com|Fred Enriquez>\"}}]"
            ],
            "description": "**DEPRECATED**: Use `markdown_text` field instead. JSON array of structured blocks as a URL-encoded string for message layout and design. Required if `text` and `attachments` are not provided."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "Post as the authenticated user, not a bot. Defaults to false. See Slack's `chat.postMessage` docs for authorship."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "#general",
              "U1234567890"
            ],
            "description": "Channel, private group, or DM channel ID (e.g., C1234567890) or name (e.g., #general) to send the message to."
          },
          "post_at": {
            "type": "string",
            "title": "Post At",
            "examples": [
              "1678886400"
            ],
            "description": "Unix EPOCH timestamp (integer seconds since 1970-01-01 00:00:00 UTC) for the future message send time."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "examples": [
              "1405894322.002768"
            ],
            "description": "Timestamp of the parent message for the scheduled message to be a thread reply. Must be float seconds (e.g., `1234567890.123456`)."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "description": "Pass true to automatically link channel names (e.g., #general) and usernames (e.g., @user)."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "[{\"color\": \"good\", \"text\": \"Yay! You did it!\", \"fields\": [{\"title\": \"Priority\", \"value\": \"High\", \"short\": false}]}]"
            ],
            "description": "JSON array of structured attachments as a URL-encoded string for rich content. Required if `text` and `blocks` are not provided."
          },
          "unfurl_links": {
            "type": "boolean",
            "title": "Unfurl Links",
            "description": "Pass false to disable automatic link unfurling. Defaults to true."
          },
          "unfurl_media": {
            "type": "boolean",
            "title": "Unfurl Media",
            "description": "Pass false to disable automatic media unfurling. Defaults to true."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Scheduled Reminder\n\nDon't forget about the **team meeting** tomorrow at *2 PM*!\n\n```\nZoom: https://zoom.us/meeting-id\n```",
              "## Weekly Report\n\n- **Tasks completed**: 12\n- *In progress*: 3\n- ~~Blocked~~: **Resolved**\n\n---\n\n**Due**: End of week"
            ],
            "description": "**PREFERRED**: Write your scheduled message in markdown for nicely formatted display. Supports headers (#), bold (**text**), italic (*text*), strikethrough (~~text~~), code (```), links ([text](url)), quotes (>), and dividers (---). Your message will be posted with beautiful formatting."
          },
          "reply_broadcast": {
            "type": "boolean",
            "title": "Reply Broadcast",
            "description": "With `thread_ts`, makes reply visible to all in channel, not just thread members. Defaults to `false`."
          }
        },
        "description": "Request schema for `ScheduleMessage`"
      }
    },
    {
      "name": "SLACKBOT_SEARCH_ALL",
      "description": "Tool to search all messages and files. Use when you need unified content search across channels and files in one call.",
      "inputSchema": {
        "type": "object",
        "title": "SearchAllRequest",
        "required": [
          "query"
        ],
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "default": null,
            "examples": [
              1,
              2,
              3
            ],
            "nullable": true,
            "description": "Page number of results to return; default is 1."
          },
          "sort": {
            "type": "string",
            "title": "Sort",
            "default": null,
            "examples": [
              "score",
              "timestamp"
            ],
            "nullable": true,
            "description": "Sort by `score` (relevance) or `timestamp` (chronological)."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": null,
            "examples": [
              20,
              50,
              100
            ],
            "nullable": true,
            "description": "Number of results per page; default is 20; max is 100."
          },
          "query": {
            "type": "string",
            "title": "Query",
            "examples": [
              "error report",
              "in:#channel from:@user has:file"
            ],
            "description": "Search query supporting Slack search modifiers/booleans."
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "default": null,
            "nullable": true,
            "description": "Encoded team ID to search in; required when using an org-level token."
          },
          "sort_dir": {
            "type": "string",
            "title": "Sort Dir",
            "default": null,
            "examples": [
              "asc",
              "desc"
            ],
            "nullable": true,
            "description": "Sort direction: `asc` or `desc`."
          },
          "highlight": {
            "type": "boolean",
            "title": "Highlight",
            "default": null,
            "examples": [
              true,
              false
            ],
            "nullable": true,
            "description": "If true, search terms are wrapped with markers for client-side highlighting."
          }
        },
        "description": "Request schema for `SearchAll`"
      }
    },
    {
      "name": "SLACKBOT_SEARCH_FOR_MESSAGES_WITH_QUERY",
      "description": "DEPRECATED: Searches messages in a Slack workspace using a query with optional modifiers. Use `search_messages` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SearchMessagesRequest",
        "required": [
          "query"
        ],
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "examples": [
              1,
              2,
              3
            ],
            "description": "Page number for manual pagination control. Cannot be used with auto_paginate - choose either automatic collection OR manual page control, not both."
          },
          "sort": {
            "type": "string",
            "title": "Sort",
            "examples": [
              "score",
              "timestamp"
            ],
            "description": "Sort results by `score` (relevance) or `timestamp` (chronological)."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": 1,
            "examples": [
              20,
              50,
              100,
              500,
              1000
            ],
            "description": "Without auto_paginate: Number of messages per page (max 100). With auto_paginate: Total messages desired. Set count=500 to get 500 messages with automatic pagination handling."
          },
          "query": {
            "type": "string",
            "title": "Query",
            "examples": [
              "on:2025-09-25",
              "after:2025-01-01 before:2025-12-31",
              "during:september",
              "during:2025-09-25",
              "product launch in:#marketing",
              "bug report from:@jane has:file",
              "\"meeting notes\" on:2024-07-20",
              "urgent -resolved in:#support",
              "\"project update\" on:2025-09-25 from:@john in:#team-updates",
              "has:link during:august from:@bot",
              "deployment after:2025-09-20 in:#engineering"
            ],
            "description": "Search query supporting various modifiers for precise filtering:\n                \n        **Date Modifiers:**\n        - `on:YYYY-MM-DD` - Messages on specific date (e.g., `on:2025-09-25`)\n        - `before:YYYY-MM-DD` - Messages before date\n        - `after:YYYY-MM-DD` - Messages after date  \n        - `during:YYYY-MM-DD` or `during:month` or `during:YYYY` - Messages during day/month/year\n\n        **Location Modifiers:**\n        - `in:#channel-name` - Messages in specific channel\n        - `in:@username` - Direct messages with user\n\n        **User Modifiers:**\n        - `from:@username` - Messages from specific user\n        - `from:botname` - Messages from bot\n\n        **Content Modifiers:**\n        - `has:link` - Messages with links\n        - `has:file` - Messages with files\n        - `has::star:` - Starred messages\n        - `has::pin:` - Pinned messages\n\n        **Special Characters:**\n        - `\"exact phrase\"` - Search exact phrase\n        - `*wildcard` - Wildcard matching\n        - `-exclude` - Exclude words\n\n        **Combinations:** Mix modifiers like `\"project update\" on:2025-09-25 in:#marketing from:@john`"
          },
          "sort_dir": {
            "type": "string",
            "title": "Sort Dir",
            "examples": [
              "asc",
              "desc"
            ],
            "description": "Sort direction: `asc` (ascending) or `desc` (descending)."
          },
          "highlight": {
            "type": "boolean",
            "title": "Highlight",
            "examples": [
              true,
              false
            ],
            "description": "Enable highlighting of search terms in results."
          },
          "auto_paginate": {
            "type": "boolean",
            "title": "Auto Paginate",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "When enabled, 'count' becomes the total messages desired instead of per-page limit. System automatically handles pagination to collect the specified total. Cannot be used with 'page' parameter - choose either automatic collection or manual page control. Usage: If you fetched 100 messages but pagination shows 500 total available, set auto_paginate=true and count=500 to get all results at once."
          }
        },
        "description": "Request schema for `SearchMessages`"
      }
    },
    {
      "name": "SLACKBOT_SEARCH_MESSAGES",
      "description": "Workspace\u2011wide Slack message search with date ranges and filters. Use `query` modifiers (e.g., in:#channel, from:@user, before/after:YYYY-MM-DD), sorting (score/timestamp), and pagination.",
      "inputSchema": {
        "type": "object",
        "title": "SearchMessagesRequest",
        "required": [
          "query"
        ],
        "properties": {
          "page": {
            "type": "integer",
            "title": "Page",
            "examples": [
              1,
              2,
              3
            ],
            "description": "Page number for manual pagination control. Cannot be used with auto_paginate - choose either automatic collection OR manual page control, not both."
          },
          "sort": {
            "type": "string",
            "title": "Sort",
            "examples": [
              "score",
              "timestamp"
            ],
            "description": "Sort results by `score` (relevance) or `timestamp` (chronological)."
          },
          "count": {
            "type": "integer",
            "title": "Count",
            "default": 1,
            "examples": [
              20,
              50,
              100,
              500,
              1000
            ],
            "description": "Without auto_paginate: Number of messages per page (max 100). With auto_paginate: Total messages desired. Set count=500 to get 500 messages with automatic pagination handling."
          },
          "query": {
            "type": "string",
            "title": "Query",
            "examples": [
              "on:2025-09-25",
              "after:2025-01-01 before:2025-12-31",
              "during:september",
              "during:2025-09-25",
              "product launch in:#marketing",
              "bug report from:@jane has:file",
              "\"meeting notes\" on:2024-07-20",
              "urgent -resolved in:#support",
              "\"project update\" on:2025-09-25 from:@john in:#team-updates",
              "has:link during:august from:@bot",
              "deployment after:2025-09-20 in:#engineering"
            ],
            "description": "Search query supporting various modifiers for precise filtering:\n                \n        **Date Modifiers:**\n        - `on:YYYY-MM-DD` - Messages on specific date (e.g., `on:2025-09-25`)\n        - `before:YYYY-MM-DD` - Messages before date\n        - `after:YYYY-MM-DD` - Messages after date  \n        - `during:YYYY-MM-DD` or `during:month` or `during:YYYY` - Messages during day/month/year\n\n        **Location Modifiers:**\n        - `in:#channel-name` - Messages in specific channel\n        - `in:@username` - Direct messages with user\n\n        **User Modifiers:**\n        - `from:@username` - Messages from specific user\n        - `from:botname` - Messages from bot\n\n        **Content Modifiers:**\n        - `has:link` - Messages with links\n        - `has:file` - Messages with files\n        - `has::star:` - Starred messages\n        - `has::pin:` - Pinned messages\n\n        **Special Characters:**\n        - `\"exact phrase\"` - Search exact phrase\n        - `*wildcard` - Wildcard matching\n        - `-exclude` - Exclude words\n\n        **Combinations:** Mix modifiers like `\"project update\" on:2025-09-25 in:#marketing from:@john`"
          },
          "sort_dir": {
            "type": "string",
            "title": "Sort Dir",
            "examples": [
              "asc",
              "desc"
            ],
            "description": "Sort direction: `asc` (ascending) or `desc` (descending)."
          },
          "highlight": {
            "type": "boolean",
            "title": "Highlight",
            "examples": [
              true,
              false
            ],
            "description": "Enable highlighting of search terms in results."
          },
          "auto_paginate": {
            "type": "boolean",
            "title": "Auto Paginate",
            "default": false,
            "examples": [
              true,
              false
            ],
            "description": "When enabled, 'count' becomes the total messages desired instead of per-page limit. System automatically handles pagination to collect the specified total. Cannot be used with 'page' parameter - choose either automatic collection or manual page control. Usage: If you fetched 100 messages but pagination shows 500 total available, set auto_paginate=true and count=500 to get all results at once."
          }
        },
        "description": "Request schema for `SearchMessages`"
      }
    },
    {
      "name": "SLACKBOT_SEND_EPHEMERAL_MESSAGE",
      "description": "Sends an ephemeral message to a user in a channel.",
      "inputSchema": {
        "type": "object",
        "title": "SendEphemeralMessageRequest",
        "required": [
          "channel",
          "user"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "default": null,
            "examples": [
              "Hello world"
            ],
            "nullable": true,
            "description": "How this field works and whether it is required depends on other fields you use in your API call. See below for more detail."
          },
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U0BPQUNTA"
            ],
            "description": "User ID of the user to send the ephemeral message to."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "default": null,
            "examples": [
              "full"
            ],
            "nullable": true,
            "description": "Change how messages are treated. Defaults to none. See below."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "default": null,
            "examples": [
              "[{\"type\": \"section\", \"text\": {\"type\": \"plain_text\", \"text\": \"Hello world\"}}]"
            ],
            "nullable": true,
            "description": "A JSON-based array of structured blocks, presented as a URL-encoded string."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See authorship below."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name."
          },
          "icon_url": {
            "type": "string",
            "title": "Icon Url",
            "default": null,
            "examples": [
              "http://lorempixel.com/48/48"
            ],
            "nullable": true,
            "description": "URL to an image to use as the icon for this message. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "default": null,
            "examples": [
              "My Bot"
            ],
            "nullable": true,
            "description": "Set your bot's user name. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "default": null,
            "examples": [
              "1234567890.123456"
            ],
            "nullable": true,
            "description": "Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead."
          },
          "icon_emoji": {
            "type": "string",
            "title": "Icon Emoji",
            "default": null,
            "examples": [
              ":chart_with_upwards_trend:"
            ],
            "nullable": true,
            "description": "Emoji to use as the icon for this message. Overrides icon_url. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Find and link channel names and usernames."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "default": null,
            "examples": [
              "[{\"pretext\": \"pre-hello\", \"text\": \"text-world\"}]"
            ],
            "nullable": true,
            "description": "A JSON-based array of structured attachments, presented as a URL-encoded string."
          }
        },
        "description": "Request schema for `SendEphemeralMessage`"
      }
    },
    {
      "name": "SLACKBOT_SEND_MESSAGE",
      "description": "Posts a message to a Slack channel, direct message, or private group; requires content via `text`, `blocks`, or `attachments`.",
      "inputSchema": {
        "type": "object",
        "title": "SendMessageRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello from your friendly bot!",
              "Reminder: Team meeting at 3 PM today."
            ],
            "description": "DEPRECATED: This sends raw text only, use markdown_text field. Primary textual content. Recommended fallback if using `blocks` or `attachments`. Supports mrkdwn unless `mrkdwn` is `false`."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "none",
              "full"
            ],
            "description": "Message text parsing behavior. Default `none` (no special parsing). `full` parses as user-typed (links @mentions, #channels). See Slack API docs for details."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "%5B%7B%22type%22%3A%20%22section%22%2C%20%22text%22%3A%20%7B%22type%22%3A%20%22mrkdwn%22%2C%20%22text%22%3A%20%22Hello%2C%20world%21%22%7D%7D%5D"
            ],
            "description": "DEPRECATED: Use `markdown_text` field instead. URL-encoded JSON array of layout blocks for rich/interactive messages. See Slack API Block Kit docs for structure."
          },
          "mrkdwn": {
            "type": "boolean",
            "title": "Mrkdwn",
            "description": "Disable Slack's markdown for `text` field if `false`. Default `true` (allows *bold*, _italic_, etc.)."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "Post as the authenticated user instead of as a bot. Defaults to `false`. If `true`, `username`, `icon_emoji`, and `icon_url` are ignored. If `false`, the message is posted as a bot, allowing appearance customization."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "ID or name of the channel, private group, or IM channel to send the message to."
          },
          "icon_url": {
            "type": "string",
            "title": "Icon Url",
            "examples": [
              "https://slack.com/img/icons/appDir_2019_01/Tonito64.png"
            ],
            "description": "Image URL for bot's icon (must be HTTPS). Applies if `as_user` is `false`."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "examples": [
              "MyBot",
              "AlertBot"
            ],
            "description": "Bot's name in Slack (max 80 chars). Applies if `as_user` is `false`."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "examples": [
              "1618033790.001500"
            ],
            "description": "Timestamp (`ts`) of an existing message to make this a threaded reply. Use `ts` of the parent message, not another reply. Example: '1476746824.000004'."
          },
          "icon_emoji": {
            "type": "string",
            "title": "Icon Emoji",
            "examples": [
              ":tada:",
              ":slack:"
            ],
            "description": "Emoji for bot's icon (e.g., ':robot_face:'). Overrides `icon_url`. Applies if `as_user` is `false`."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "description": "Automatically hyperlink channel names (e.g., #channel) and usernames (e.g., @user) in message text. Defaults to `false` for bot messages."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "%5B%7B%22fallback%22%3A%20%22Required%20plain-text%20summary%20of%20the%20attachment.%22%2C%20%22color%22%3A%20%22%2336a64f%22%2C%20%22pretext%22%3A%20%22Optional%20text%20that%20appears%20above%20the%20attachment%20block%22%2C%20%22author_name%22%3A%20%22Bobby%20Tables%22%2C%20%22title%22%3A%20%22Slack%20API%20Documentation%22%2C%20%22title_link%22%3A%20%22https%3A%2F%2Fapi.slack.com%2F%22%2C%20%22text%22%3A%20%22Optional%20text%20that%20appears%20within%20the%20attachment%22%7D%5D"
            ],
            "description": "URL-encoded JSON array of message attachments, a legacy method for rich content. See Slack API documentation for structure."
          },
          "unfurl_links": {
            "type": "boolean",
            "title": "Unfurl Links",
            "description": "Enable unfurling of text-based URLs. Defaults `false` for bots, `true` if `as_user` is `true`."
          },
          "unfurl_media": {
            "type": "boolean",
            "title": "Unfurl Media",
            "description": "Disable unfurling of media content from URLs if `false`. Defaults to `true`."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Status Update\n\nSystem is **running smoothly** with *excellent* performance.\n\n```bash\nkubectl get pods\n```\n\n> All services operational \u2705",
              "## Daily Report\n\n- **Deployments**: 5 successful\n- *Issues*: 0 critical\n- ~~Maintenance~~: **Completed**\n\n---\n\n**Next**: Monitor for 24h"
            ],
            "description": "PREFERRED: Write your message in markdown for nicely formatted display. Supports: headers (# ## ###), bold (**text** or __text__), italic (*text* or _text_), strikethrough (~~text~~), inline code (`code`), code blocks (```), links ([text](url)), block quotes (>), lists (- item, 1. item), dividers (--- or ***), context blocks (:::context with images), and section buttons (:::section-button). IMPORTANT: Use \\n for line breaks (e.g., 'Line 1\\nLine 2'), not actual newlines. USER MENTIONS: To tag users, use their user ID with <@USER_ID> format (e.g., <@U1234567890>), not username. "
          },
          "reply_broadcast": {
            "type": "boolean",
            "title": "Reply Broadcast",
            "description": "If `true` for a threaded reply, also posts to main channel. Defaults to `false`."
          }
        },
        "description": "Request schema for `SendMessage`"
      }
    },
    {
      "name": "SLACKBOT_SENDS_A_MESSAGE_TO_A_CHANNEL",
      "description": "DEPRECATED: Posts a message to a Slack channel, direct message, or private group. Use `send_message` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SendMessageRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello from your friendly bot!",
              "Reminder: Team meeting at 3 PM today."
            ],
            "description": "DEPRECATED: This sends raw text only, use markdown_text field. Primary textual content. Recommended fallback if using `blocks` or `attachments`. Supports mrkdwn unless `mrkdwn` is `false`."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "none",
              "full"
            ],
            "description": "Message text parsing behavior. Default `none` (no special parsing). `full` parses as user-typed (links @mentions, #channels). See Slack API docs for details."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "%5B%7B%22type%22%3A%20%22section%22%2C%20%22text%22%3A%20%7B%22type%22%3A%20%22mrkdwn%22%2C%20%22text%22%3A%20%22Hello%2C%20world%21%22%7D%7D%5D"
            ],
            "description": "DEPRECATED: Use `markdown_text` field instead. URL-encoded JSON array of layout blocks for rich/interactive messages. See Slack API Block Kit docs for structure."
          },
          "mrkdwn": {
            "type": "boolean",
            "title": "Mrkdwn",
            "description": "Disable Slack's markdown for `text` field if `false`. Default `true` (allows *bold*, _italic_, etc.)."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "description": "Post as the authenticated user instead of as a bot. Defaults to `false`. If `true`, `username`, `icon_emoji`, and `icon_url` are ignored. If `false`, the message is posted as a bot, allowing appearance customization."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "general"
            ],
            "description": "ID or name of the channel, private group, or IM channel to send the message to."
          },
          "icon_url": {
            "type": "string",
            "title": "Icon Url",
            "examples": [
              "https://slack.com/img/icons/appDir_2019_01/Tonito64.png"
            ],
            "description": "Image URL for bot's icon (must be HTTPS). Applies if `as_user` is `false`."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "examples": [
              "MyBot",
              "AlertBot"
            ],
            "description": "Bot's name in Slack (max 80 chars). Applies if `as_user` is `false`."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "examples": [
              "1618033790.001500"
            ],
            "description": "Timestamp (`ts`) of an existing message to make this a threaded reply. Use `ts` of the parent message, not another reply. Example: '1476746824.000004'."
          },
          "icon_emoji": {
            "type": "string",
            "title": "Icon Emoji",
            "examples": [
              ":tada:",
              ":slack:"
            ],
            "description": "Emoji for bot's icon (e.g., ':robot_face:'). Overrides `icon_url`. Applies if `as_user` is `false`."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "description": "Automatically hyperlink channel names (e.g., #channel) and usernames (e.g., @user) in message text. Defaults to `false` for bot messages."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "%5B%7B%22fallback%22%3A%20%22Required%20plain-text%20summary%20of%20the%20attachment.%22%2C%20%22color%22%3A%20%22%2336a64f%22%2C%20%22pretext%22%3A%20%22Optional%20text%20that%20appears%20above%20the%20attachment%20block%22%2C%20%22author_name%22%3A%20%22Bobby%20Tables%22%2C%20%22title%22%3A%20%22Slack%20API%20Documentation%22%2C%20%22title_link%22%3A%20%22https%3A%2F%2Fapi.slack.com%2F%22%2C%20%22text%22%3A%20%22Optional%20text%20that%20appears%20within%20the%20attachment%22%7D%5D"
            ],
            "description": "URL-encoded JSON array of message attachments, a legacy method for rich content. See Slack API documentation for structure."
          },
          "unfurl_links": {
            "type": "boolean",
            "title": "Unfurl Links",
            "description": "Enable unfurling of text-based URLs. Defaults `false` for bots, `true` if `as_user` is `true`."
          },
          "unfurl_media": {
            "type": "boolean",
            "title": "Unfurl Media",
            "description": "Disable unfurling of media content from URLs if `false`. Defaults to `true`."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Status Update\n\nSystem is **running smoothly** with *excellent* performance.\n\n```bash\nkubectl get pods\n```\n\n> All services operational \u2705",
              "## Daily Report\n\n- **Deployments**: 5 successful\n- *Issues*: 0 critical\n- ~~Maintenance~~: **Completed**\n\n---\n\n**Next**: Monitor for 24h"
            ],
            "description": "PREFERRED: Write your message in markdown for nicely formatted display. Supports: headers (# ## ###), bold (**text** or __text__), italic (*text* or _text_), strikethrough (~~text~~), inline code (`code`), code blocks (```), links ([text](url)), block quotes (>), lists (- item, 1. item), dividers (--- or ***), context blocks (:::context with images), and section buttons (:::section-button). IMPORTANT: Use \\n for line breaks (e.g., 'Line 1\\nLine 2'), not actual newlines. USER MENTIONS: To tag users, use their user ID with <@USER_ID> format (e.g., <@U1234567890>), not username. "
          },
          "reply_broadcast": {
            "type": "boolean",
            "title": "Reply Broadcast",
            "description": "If `true` for a threaded reply, also posts to main channel. Defaults to `false`."
          }
        },
        "description": "Request schema for `SendMessage`"
      }
    },
    {
      "name": "SLACKBOT_SENDS_EPHEMERAL_MESSAGES_TO_CHANNEL_USERS",
      "description": "DEPRECATED: Sends an ephemeral message to a user in a channel. Use `send_ephemeral_message` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SendEphemeralMessageRequest",
        "required": [
          "channel",
          "user"
        ],
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "default": null,
            "examples": [
              "Hello world"
            ],
            "nullable": true,
            "description": "How this field works and whether it is required depends on other fields you use in your API call. See below for more detail."
          },
          "user": {
            "type": "string",
            "title": "User",
            "examples": [
              "U0BPQUNTA"
            ],
            "description": "User ID of the user to send the ephemeral message to."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "default": null,
            "examples": [
              "full"
            ],
            "nullable": true,
            "description": "Change how messages are treated. Defaults to none. See below."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "default": null,
            "examples": [
              "[{\"type\": \"section\", \"text\": {\"type\": \"plain_text\", \"text\": \"Hello world\"}}]"
            ],
            "nullable": true,
            "description": "A JSON-based array of structured blocks, presented as a URL-encoded string."
          },
          "as_user": {
            "type": "boolean",
            "title": "As User",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See authorship below."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "Channel, private group, or DM channel to send message to. Can be an encoded ID, or a name."
          },
          "icon_url": {
            "type": "string",
            "title": "Icon Url",
            "default": null,
            "examples": [
              "http://lorempixel.com/48/48"
            ],
            "nullable": true,
            "description": "URL to an image to use as the icon for this message. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "default": null,
            "examples": [
              "My Bot"
            ],
            "nullable": true,
            "description": "Set your bot's user name. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "thread_ts": {
            "type": "string",
            "title": "Thread Ts",
            "default": null,
            "examples": [
              "1234567890.123456"
            ],
            "nullable": true,
            "description": "Provide another message's ts value to make this message a reply. Avoid using a reply's ts value; use its parent instead."
          },
          "icon_emoji": {
            "type": "string",
            "title": "Icon Emoji",
            "default": null,
            "examples": [
              ":chart_with_upwards_trend:"
            ],
            "nullable": true,
            "description": "Emoji to use as the icon for this message. Overrides icon_url. Must be used in conjunction with as_user set to false, otherwise ignored. See authorship below."
          },
          "link_names": {
            "type": "boolean",
            "title": "Link Names",
            "default": null,
            "examples": [
              true
            ],
            "nullable": true,
            "description": "Find and link channel names and usernames."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "default": null,
            "examples": [
              "[{\"pretext\": \"pre-hello\", \"text\": \"text-world\"}]"
            ],
            "nullable": true,
            "description": "A JSON-based array of structured attachments, presented as a URL-encoded string."
          }
        },
        "description": "Request schema for `SendEphemeralMessage`"
      }
    },
    {
      "name": "SLACKBOT_SET_A_CONVERSATION_S_PURPOSE",
      "description": "Sets the purpose (a short description of its topic/goal, displayed in the header) for a Slack conversation; the calling user must be a member.",
      "inputSchema": {
        "type": "object",
        "title": "SetAConversationSPurposeRequest",
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C012AB3CD4E",
              "D0G9ALE3P",
              "G12345678"
            ],
            "description": "The ID of the conversation (channel, direct message, or group message) to set the purpose for."
          },
          "purpose": {
            "type": "string",
            "title": "Purpose",
            "examples": [
              "Discuss project milestones and deadlines.",
              "Team updates and daily stand-ups."
            ],
            "description": "The new purpose for the conversation. This text will be displayed as the channel description. The maximum length is 250 characters."
          }
        },
        "description": "Request schema for `SetAConversationSPurpose`"
      }
    },
    {
      "name": "SLACKBOT_SET_DND_DURATION",
      "description": "Turns on Do Not Disturb mode for the current user, or changes its duration.",
      "inputSchema": {
        "type": "object",
        "title": "SetDndDurationRequest",
        "required": [
          "num_minutes"
        ],
        "properties": {
          "num_minutes": {
            "type": "string",
            "title": "Num Minutes",
            "examples": [
              "60"
            ],
            "description": "Number of minutes, from now, to snooze until."
          }
        },
        "description": "Request schema for `SetDndDuration`"
      }
    },
    {
      "name": "SLACKBOT_SET_PROFILE_PHOTO",
      "description": "This method allows the user to set their profile image.",
      "inputSchema": {
        "type": "object",
        "title": "SetProfilePhotoRequest",
        "required": [
          "image"
        ],
        "properties": {
          "image": {
            "type": "string",
            "title": "Image",
            "description": "File contents via a POST var called image."
          },
          "crop_w": {
            "type": "integer",
            "title": "Crop W",
            "default": null,
            "nullable": true,
            "description": "Width/height of crop box (always square)"
          },
          "crop_x": {
            "type": "integer",
            "title": "Crop X",
            "default": null,
            "nullable": true,
            "description": "X coordinate of top-left corner of crop box"
          },
          "crop_y": {
            "type": "integer",
            "title": "Crop Y",
            "default": null,
            "nullable": true,
            "description": "Y coordinate of top-left corner of crop box"
          }
        },
        "description": "Request schema for `SetProfilePhoto`"
      }
    },
    {
      "name": "SLACKBOT_SET_READ_CURSOR_IN_A_CONVERSATION",
      "description": "Marks a message, specified by its timestamp (`ts`), as the most recently read for the authenticated user in the given `channel`, provided the user is a member of the channel and the message exists within it.",
      "inputSchema": {
        "type": "object",
        "title": "SetReadCursorInAConversationRequest",
        "properties": {
          "ts": {
            "type": "integer",
            "title": "Ts",
            "examples": [
              "1678886400.000100",
              "1702982400.123456"
            ],
            "description": "The timestamp of the message to mark as the most recently read. This is typically a Unix timestamp with microsecond precision (e.g., '1625800000.000200')."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C012QRSTUW9",
              "G012ABCDEFG",
              "D012HIJKLMN"
            ],
            "description": "The ID of the public channel, private channel, or direct message to set the read cursor for."
          }
        },
        "description": "Request schema for `SetReadCursorInAConversation`"
      }
    },
    {
      "name": "SLACKBOT_SET_STATUS",
      "description": "Sets the Slack status for the authenticated user with a custom text and optional emoji. The status appears next to the user's name in Slack.",
      "inputSchema": {
        "type": "object",
        "title": "SetStatusRequest",
        "required": [
          "status_text"
        ],
        "properties": {
          "status_text": {
            "type": "string",
            "title": "Status Text",
            "examples": [
              "In a meeting",
              "AFK",
              "Out for lunch",
              "Focusing \ud83c\udfaf"
            ],
            "maxLength": 100,
            "description": "The status text to set (e.g., 'In a meeting', 'Out for lunch', 'Working remotely'). Maximum 100 characters."
          },
          "status_emoji": {
            "type": "string",
            "title": "Status Emoji",
            "default": null,
            "examples": [
              ":coffee:",
              ":calendar:",
              ":house:",
              ":computer:"
            ],
            "nullable": true,
            "description": "Optional emoji to display with the status (e.g., ':coffee:', ':calendar:', ':house:'). Must be in :emoji_name: format."
          },
          "status_expiration": {
            "type": "integer",
            "title": "Status Expiration",
            "default": null,
            "examples": [
              1640995200,
              1672531200
            ],
            "nullable": true,
            "description": "Optional Unix timestamp (in seconds) when the status should expire and be automatically cleared. If not provided, status persists until manually cleared."
          }
        }
      }
    },
    {
      "name": "SLACKBOT_SET_THE_TOPIC_OF_A_CONVERSATION",
      "description": "Sets or updates the topic for a specified Slack conversation.",
      "inputSchema": {
        "type": "object",
        "title": "SetTheTopicOfAConversationRequest",
        "properties": {
          "topic": {
            "type": "string",
            "title": "Topic",
            "examples": [
              "Q4 Planning Discussion",
              "Weekly Sync Updates"
            ],
            "description": "The new topic for the conversation. It must be a string up to 250 characters long. Text formatting and linkification are not supported."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0123456789",
              "D012345678"
            ],
            "description": "The ID of the public channel, private channel, direct message, or multi-person direct message conversation for which the topic will be set."
          }
        },
        "description": "Request schema for `SetTheTopicOfAConversation`"
      }
    },
    {
      "name": "SLACKBOT_SET_USER_PROFILE_INFORMATION",
      "description": "Updates a Slack user's profile, setting either individual fields or multiple fields via a JSON object.",
      "inputSchema": {
        "type": "object",
        "title": "SetSlackUserProfileInformationRequest",
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "default": null,
            "examples": [
              "first_name",
              "status_text",
              "custom_field_id_X123"
            ],
            "nullable": true,
            "description": "Name of a single profile field to set. Use with `value` if `profile` is not provided."
          },
          "user": {
            "type": "string",
            "title": "User",
            "default": null,
            "examples": [
              "U012A3CDE"
            ],
            "nullable": true,
            "description": "ID of the user whose profile will be updated; defaults to authenticated user. Team admins on paid teams can specify another member's ID."
          },
          "value": {
            "type": "string",
            "title": "Value",
            "default": null,
            "examples": [
              "John Doe",
              "On a call",
              "New custom value"
            ],
            "nullable": true,
            "description": "Value for the single profile field specified by `name`. Use with `name` if `profile` is not provided."
          },
          "profile": {
            "type": "string",
            "title": "Profile",
            "default": null,
            "examples": [
              "%7B%22first_name%22%3A%22Alice%22%2C%20%22last_name%22%3A%22Wonderland%22%2C%20%22status_text%22%3A%22Exploring%22%2C%20%22status_emoji%22%3A%22%3Arabbit%3A%22%7D"
            ],
            "nullable": true,
            "description": "URL-encoded JSON string of key-value pairs for profile fields to update (max 50 fields, 255 chars per field name). If provided, `name` and `value` are ignored."
          }
        },
        "description": "Request schema for updating a Slack user's profile information."
      }
    },
    {
      "name": "SLACKBOT_SET_USER_PROFILE_PHOTO_WITH_CROPPING_OPTIONS",
      "description": "DEPRECATED: This method allows the user to set their profile image. Use `set_profile_photo` instead.",
      "inputSchema": {
        "type": "object",
        "title": "SetProfilePhotoRequest",
        "required": [
          "image"
        ],
        "properties": {
          "image": {
            "type": "string",
            "title": "Image",
            "description": "File contents via a POST var called image."
          },
          "crop_w": {
            "type": "integer",
            "title": "Crop W",
            "default": null,
            "nullable": true,
            "description": "Width/height of crop box (always square)"
          },
          "crop_x": {
            "type": "integer",
            "title": "Crop X",
            "default": null,
            "nullable": true,
            "description": "X coordinate of top-left corner of crop box"
          },
          "crop_y": {
            "type": "integer",
            "title": "Crop Y",
            "default": null,
            "nullable": true,
            "description": "Y coordinate of top-left corner of crop box"
          }
        },
        "description": "Request schema for `SetProfilePhoto`"
      }
    },
    {
      "name": "SLACKBOT_SHARE_A_ME_MESSAGE_IN_A_CHANNEL",
      "description": "Sends a 'me message' (e.g., '/me is typing') to a Slack channel, where it's displayed as a third-person user action; messages are plain text and the channel must exist and be accessible.",
      "inputSchema": {
        "type": "object",
        "title": "ShareAMeMessageInAChannelRequest",
        "properties": {
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "is preparing for a meeting.",
              "updated the project status.",
              "needs coffee."
            ],
            "description": "Content of the 'me message', displayed as an action performed by the user (e.g., if text is 'is feeling happy', it appears as '*User is feeling happy*')."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "#random",
              "D012345678"
            ],
            "description": "Specifies the target channel by its public ID (e.g., 'C1234567890'), private group ID, IM channel ID, or name (e.g., '#general', '@username')."
          }
        },
        "description": "Request schema for `ShareAMeMessageInAChannel`"
      }
    },
    {
      "name": "SLACKBOT_SHARE_REMOTE_FILE_IN_CHANNELS",
      "description": "Shares a remote file, which must already be registered with Slack, into specified Slack channels or direct message conversations.",
      "inputSchema": {
        "type": "object",
        "title": "ShareRemoteFileInChannelsRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F0123456789"
            ],
            "description": "The unique ID of the remote file registered with Slack. Either this `file` field or the `external_id` field (or both) is required to identify the file."
          },
          "channels": {
            "type": "string",
            "title": "Channels",
            "examples": [
              "C0123456789,D0987654321",
              "C061MP4F097"
            ],
            "description": "A comma-separated list of channel IDs where the remote file will be shared. These can include public channel IDs, private channel IDs, or direct message channel IDs."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "myapp-unique-file-id-007",
              "external-doc-id-54321"
            ],
            "description": "The globally unique identifier (GUID) for the remote file, as provided by the app that registered it with Slack. Either this `external_id` field or the `file` field (or both) is required to identify the file."
          }
        },
        "description": "Request schema for `ShareRemoteFileInChannels`"
      }
    },
    {
      "name": "SLACKBOT_START_CALL",
      "description": "Registers a new call in Slack using `calls.add` for third-party call integration; `created_by` is required if not using a user-specific token.",
      "inputSchema": {
        "type": "object",
        "title": "StartCallRequest",
        "required": [
          "external_unique_id",
          "join_url"
        ],
        "properties": {
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Project Alpha Sync",
              "Q3 Planning Session"
            ],
            "description": "The name or title for the call. This will be displayed in Slack to identify the call."
          },
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "'''[{\"slack_id\": \"U012A3BCD4E\"}, {\"external_id\": \"participant1@example.com\", \"slack_id\": \"U012A3BCD4F\"}]'''",
              "'''[{\"slack_id\": \"W012A3CDE\"}]'''",
              "'''[{\"external_id\": \"meeting-user-789\"}]'''"
            ],
            "description": "A JSON string representing an array of user objects to be registered as participants in the call. Each user object in the array should define a participant using their `slack_id` (Slack User ID) and/or an `external_id` (an identifier from the third-party application, unique to that user within that application). For instance: `'''[{\"slack_id\": \"U012A3BCD4E\"}, {\"external_id\": \"user-xyz@example.com\", \"slack_id\": \"U012A3BCD4F\"}]'''`."
          },
          "join_url": {
            "type": "string",
            "title": "Join Url",
            "examples": [
              "https://thirdparty.call/join/meeting123",
              "https://example.com/s/abc-123-def"
            ],
            "description": "The URL required for a client to join the call (e.g., a web join link). This field is mandatory."
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "examples": [
              "U012A3BCD4E",
              "U061F7AUR"
            ],
            "description": "Slack user ID of the creator; optional (defaults to authenticated user) if using a user token, otherwise required."
          },
          "date_start": {
            "type": "integer",
            "title": "Date Start",
            "examples": [
              "1678886400",
              "1700000000"
            ],
            "description": "The start time of the call, specified as a UTC UNIX timestamp in seconds. For example, `1678886400` corresponds to March 15, 2023, at 12:00 PM UTC."
          },
          "external_unique_id": {
            "type": "string",
            "title": "External Unique Id",
            "examples": [
              "v=abcdef123456",
              "call-ext-98765uuid-from-provider"
            ],
            "description": "A unique identifier for the call, supplied by the third-party call provider. This ID must be unique across all calls from that specific service. This field is required."
          },
          "external_display_id": {
            "type": "string",
            "title": "External Display Id",
            "examples": [
              "Meeting H.323",
              "CONF-7890"
            ],
            "description": "An optional, human-readable identifier for the call, supplied by the third-party call provider. If provided, this ID will be displayed in the Slack call object interface."
          },
          "desktop_app_join_url": {
            "type": "string",
            "title": "Desktop App Join Url",
            "examples": [
              "your-app-protocol://call/12345",
              "zoomus://zoom.us/join?confno=1234567890"
            ],
            "description": "An optional URL that, when provided, allows Slack clients to attempt to directly launch the third-party call application. This is typically a deep link URI for the specific application."
          }
        },
        "description": "Request payload for registering a new call with participants in Slack."
      }
    },
    {
      "name": "SLACKBOT_START_REAL_TIME_MESSAGING_SESSION",
      "description": "Initiates a Slack RTM session providing a single-use WebSocket URL (valid 30s) for event streaming; does not set initial presence status.",
      "inputSchema": {
        "type": "object",
        "title": "StartRealTimeMessagingSessionRequest",
        "properties": {
          "presence_sub": {
            "type": "boolean",
            "title": "Presence Sub",
            "default": null,
            "examples": [
              true,
              false
            ],
            "nullable": true,
            "description": "Delivers presence events only for explicitly subscribed users if `True`. See Slack's [presence subscriptions](https://slack.dev) documentation."
          },
          "batch_presence_aware": {
            "type": "boolean",
            "title": "Batch Presence Aware",
            "default": null,
            "examples": [
              true,
              false
            ],
            "nullable": true,
            "description": "Enables batching of presence status deliveries for subscribed users if `True`, altering `presence_change` event structure. See Slack's [batch presence](https://slack.dev) documentation."
          }
        },
        "description": "Request schema for `StartRealTimeMessagingSession`."
      }
    },
    {
      "name": "SLACKBOT_UNARCHIVE_A_PUBLIC_OR_PRIVATE_CHANNEL",
      "description": "Unarchives a specified public or private Slack channel that is currently archived, using its channel ID.",
      "inputSchema": {
        "type": "object",
        "title": "UnarchiveAPublicOrPrivateChannelRequest",
        "required": [
          "channel_id"
        ],
        "properties": {
          "channel_id": {
            "type": "string",
            "title": "Channel Id",
            "examples": [
              "C0123456789",
              "G0987654321"
            ],
            "description": "The unique identifier of the public or private channel to be unarchived."
          }
        },
        "description": "Request schema for unarchiving a Slack channel."
      }
    },
    {
      "name": "SLACKBOT_UNARCHIVE_CHANNEL",
      "description": "Reverses conversation archival.",
      "inputSchema": {
        "type": "object",
        "title": "UnarchiveChannelRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890"
            ],
            "description": "ID of conversation to unarchive"
          }
        },
        "description": "Request schema for `UnarchiveChannel`"
      }
    },
    {
      "name": "SLACKBOT_UNPIN_ITEM_FROM_CHANNEL",
      "description": "Unpins a message, identified by its timestamp, from a specified channel if the message is currently pinned there; this operation is destructive.",
      "inputSchema": {
        "type": "object",
        "title": "UnpinItemFromChannelRequest",
        "required": [
          "channel"
        ],
        "properties": {
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0987654321"
            ],
            "description": "The ID of the channel where the message is pinned (e.g., a public channel, private channel, or direct message)."
          },
          "timestamp": {
            "type": "string",
            "title": "Timestamp",
            "examples": [
              "1625640000.000100",
              "1700000000.123456"
            ],
            "description": "Timestamp of the message to unpin. This is required to identify the specific message to be removed from the channel's pinned items."
          }
        },
        "description": "Request schema for `UnpinItemFromChannel`"
      }
    },
    {
      "name": "SLACKBOT_UPDATE_AN_EXISTING_USER_GROUP",
      "description": "Updates an existing Slack User Group, which must be specified by an existing `usergroup` ID, with new optional details such as its name, description, handle, or default channels.",
      "inputSchema": {
        "type": "object",
        "title": "UpdateAnExistingSlackUserGroupRequest",
        "required": [
          "usergroup"
        ],
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "examples": [
              "Q4 Marketing"
            ],
            "description": "New name for the User Group. Must be unique among User Groups."
          },
          "handle": {
            "type": "string",
            "title": "Handle",
            "examples": [
              "marketing-team-alpha"
            ],
            "description": "New mention handle. Must be unique among channels, users, and User Groups."
          },
          "channels": {
            "type": "string",
            "title": "Channels",
            "examples": [
              "C1234567890,C2345678901"
            ],
            "description": "Comma-separated encoded channel IDs to set as default channels."
          },
          "usergroup": {
            "type": "string",
            "title": "Usergroup",
            "examples": [
              "S0615G0KT"
            ],
            "description": "Encoded ID of the existing User Group to update."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "examples": [
              "Team responsible for Q4 marketing campaigns."
            ],
            "description": "New short description for the User Group."
          },
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "examples": [
              true,
              false
            ],
            "description": "If true, include the number of users in the User Group in the response."
          }
        },
        "description": "Request schema for `UpdateAnExistingSlackUserGroup`"
      }
    },
    {
      "name": "SLACKBOT_UPDATE_CALL_INFORMATION",
      "description": "Updates the title, join URL, or desktop app join URL for an existing Slack call identified by its ID.",
      "inputSchema": {
        "type": "object",
        "title": "UpdateSlackCallInformationRequest",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "examples": [
              "R0123ABCDEF",
              "R9876ZYXWVU"
            ],
            "description": "Unique identifier of the call to update, obtained when a call is created (e.g., via `calls.add` Slack API method)."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Project Alpha Review",
              "Q3 Planning Session"
            ],
            "description": "New title for the call."
          },
          "join_url": {
            "type": "string",
            "title": "Join Url",
            "examples": [
              "https://example.com/join/meeting/12345",
              "https://another-service.com/call/abc987"
            ],
            "description": "New URL for clients to join the call."
          },
          "desktop_app_join_url": {
            "type": "string",
            "title": "Desktop App Join Url",
            "examples": [
              "your-app-protocol://join?call_id=12345",
              "slack://call?id=abcdefg"
            ],
            "description": "URL to directly launch the third-party call application from Slack clients."
          }
        },
        "description": "Request schema for `UpdateSlackCallInformation`"
      }
    },
    {
      "name": "SLACKBOT_UPDATES_A_MESSAGE",
      "description": "Updates a Slack message, identified by `channel` ID and `ts` timestamp, by modifying its `text`, `attachments`, or `blocks`; provide at least one content field, noting `attachments`/`blocks` are replaced if included (`[]` clears them).",
      "inputSchema": {
        "type": "object",
        "title": "UpdatesASlackMessageRequest",
        "required": [
          "channel",
          "ts"
        ],
        "properties": {
          "ts": {
            "type": "string",
            "title": "Ts",
            "examples": [
              "1625247600.000200"
            ],
            "description": "Timestamp of the message to update (string, Unix time with microseconds, e.g., `'1234567890.123456'`)."
          },
          "text": {
            "type": "string",
            "title": "Text",
            "examples": [
              "Hello world, this is an *updated* message.",
              "Check out this link: <https://example.com>"
            ],
            "description": "This sends raw text only, use markdown_text field for formatting. New message text (plain or mrkdwn). Not required if `blocks` or `attachments` are provided. See Slack formatting rules."
          },
          "parse": {
            "type": "string",
            "title": "Parse",
            "examples": [
              "full",
              "none",
              "client"
            ],
            "description": "Parse mode for `text`: `'full'` (mrkdwn) or `'none'` (literal). If not provided, defaults to `'client'` behavior, overriding original message's `parse` setting."
          },
          "blocks": {
            "type": "string",
            "title": "Blocks",
            "examples": [
              "[{\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"This is an updated section block.\"}}]",
              "[]"
            ],
            "description": "**DEPRECATED**: Use `markdown_text` field instead. URL-encoded JSON array of layout blocks. Replaces existing blocks if field is provided; use `[]` (empty array string) to clear. Omit field to leave blocks untouched. Required if `text` and `attachments` are absent. See Slack API for format."
          },
          "as_user": {
            "type": "string",
            "title": "As User",
            "examples": [
              "true"
            ],
            "description": "Set to `'true'` to update as the authenticated user (bots are considered such). Defaults to app/bot identity."
          },
          "channel": {
            "type": "string",
            "title": "Channel",
            "examples": [
              "C1234567890",
              "G0abcdefh"
            ],
            "description": "The ID of the channel containing the message to be updated."
          },
          "link_names": {
            "type": "string",
            "title": "Link Names",
            "examples": [
              "true"
            ],
            "description": "Set to `'true'` to link channel/user names in `text`. If not provided, Slack's default update behavior may override original message's linking settings."
          },
          "attachments": {
            "type": "string",
            "title": "Attachments",
            "examples": [
              "[{\"fallback\": \"Plain-text summary of attachment.\", \"color\": \"#2eb886\", \"text\": \"Optional text that appears within the attachment\"}]",
              "[]"
            ],
            "description": "URL-encoded JSON array of attachments. Replaces existing attachments if field is provided; use `[]` (empty array string) to clear. Omit field to leave attachments untouched. Required if `text` and `blocks` are absent. See Slack API for format."
          },
          "markdown_text": {
            "type": "string",
            "title": "Markdown Text",
            "examples": [
              "# Updated Status\n\nThe issue has been **resolved** and systems are *fully operational*.\n\n```bash\n# All services running\nkubectl get services\n```",
              "## Progress Update\n\n- **Phase 1**: \u2705 Complete\n- *Phase 2*: In progress (80%)\n- ~~Phase 3~~: **Started early**\n\n---\n\n**ETA**: Tomorrow"
            ],
            "description": "**PREFERRED**: Write your updated message in markdown for nicely formatted display. Supports headers (#), bold (**text**), italic (*text*), strikethrough (~~text~~), code (```), links ([text](url)), quotes (>), and dividers (---). Your message will be posted with beautiful formatting."
          }
        },
        "description": "Request schema for `UpdatesASlackMessage` action."
      }
    },
    {
      "name": "SLACKBOT_UPDATES_AN_EXISTING_REMOTE_FILE",
      "description": "Updates metadata or content details for an existing remote file in Slack; this action cannot upload new files or change the fundamental file type.",
      "inputSchema": {
        "type": "object",
        "title": "UpdatesAnExistingRemoteFileRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "examples": [
              "F0123ABC456",
              "F7890XYZ123"
            ],
            "description": "Slack's unique identifier for the remote file (e.g., `F12345678`). Used to identify the file if `external_id` is not provided. One of `file` or `external_id` is required to specify the file to update."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "Updated Project Proposal Q3",
              "Final Presentation Draft"
            ],
            "description": "New title for the remote file. If omitted, the current title remains unchanged."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token for authorizing the API request to Slack."
          },
          "filetype": {
            "type": "string",
            "title": "Filetype",
            "examples": [
              "pdf",
              "jpg",
              "gdoc",
              "sketch",
              "txt",
              "mp4",
              "zip"
            ],
            "description": "New filetype for the remote file. This typically describes the kind of file, e.g., `pdf`, `gdoc`, `image`, `text`. See Slack API documentation for specific supported `filetype` values. Providing an inaccurate filetype might affect how the file is handled or displayed."
          },
          "external_id": {
            "type": "string",
            "title": "External Id",
            "examples": [
              "item_12345_report_2024",
              "guid-doc-xyz-final"
            ],
            "description": "Creator-defined Globally Unique Identifier (GUID) for the remote file. Used to identify the file if `file` ID is not provided. One of `file` or `external_id` is required to specify the file to update."
          },
          "external_url": {
            "type": "string",
            "title": "External Url",
            "examples": [
              "https://example.com/updated_document.pdf",
              "https://docs.google.com/spreadsheets/d/new_sheet_id_v2"
            ],
            "description": "New publicly accessible URL for the remote file. If provided, this updates the link associated with the file in Slack."
          },
          "preview_image": {
            "type": "string",
            "title": "Preview Image",
            "description": "A string that references the new preview image for the document. The referenced image data will be sent as `multipart/form-data`. This could be a local file path (if supported by the client), a public URL, or base64 encoded image data. Max 1MB. Updates the file's preview in Slack."
          },
          "indexable_file_contents": {
            "type": "string",
            "title": "Indexable File Contents",
            "description": "Plain text content extracted from the remote file, used by Slack to improve searchability. This can be a summary or the full text. Maximum 1MB. If provided, updates the searchable content."
          }
        },
        "description": "Defines the parameters for updating an existing remote file in Slack. At least `file` or `external_id` must be provided to identify the file, along with at least one attribute to modify."
      }
    },
    {
      "name": "SLACKBOT_UPDATE_USER_GROUP_MEMBERS",
      "description": "Replaces all members of an existing Slack User Group with a new list of valid user IDs.",
      "inputSchema": {
        "type": "object",
        "title": "UpdateUserGroupMembersRequest",
        "required": [
          "usergroup",
          "users"
        ],
        "properties": {
          "users": {
            "type": "string",
            "title": "Users",
            "examples": [
              "U012AB34CD,W567EF89GH,U01234567"
            ],
            "description": "Comma-separated string of encoded user IDs for the new, complete member list, replacing all existing members. User IDs typically start with 'U' or 'W'."
          },
          "usergroup": {
            "type": "string",
            "title": "Usergroup",
            "examples": [
              "S012AB34CD"
            ],
            "description": "The encoded ID of the User Group whose members are to be updated. This ID typically starts with 'S'."
          },
          "include_count": {
            "type": "boolean",
            "title": "Include Count",
            "default": null,
            "examples": [
              "true",
              "false"
            ],
            "nullable": true,
            "description": "If true, the response `usergroup` object includes `user_count` and potentially `channel_count` fields, reflecting counts after the update."
          }
        },
        "description": "Request schema for `UpdateUserGroupMembers`"
      }
    },
    {
      "name": "SLACKBOT_UPLOAD_OR_CREATE_A_FILE_IN_SLACK",
      "description": "Uploads a file to Slack, requiring either `content` (for text) or `file` (for binary data), optionally sharing it in specified `channels` or as a reply via `thread_ts`.",
      "inputSchema": {
        "type": "object",
        "title": "UploadOrCreateAFileInSlackRequest",
        "properties": {
          "file": {
            "type": "string",
            "title": "File",
            "description": "Binary file content as multipart/form-data; use for non-text files. Omit if `content` is used. Provide actual file content, not a path."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "examples": [
              "My Document",
              "Team Meeting Notes Q3"
            ],
            "description": "Title of the file, displayed in Slack."
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Authentication token; requires `files:write` scope."
          },
          "content": {
            "type": "string",
            "title": "Content",
            "examples": [
              "This is the content of my text file."
            ],
            "description": "Text content of the file; use for text-based files. Omit if `file` is used."
          },
          "channels": {
            "type": "string",
            "title": "Channels",
            "examples": [
              "C1234567890,marketing-updates",
              "general"
            ],
            "description": "Comma-separated channel names or IDs for sharing; if omitted, file is private to the uploader."
          },
          "filename": {
            "type": "string",
            "title": "Filename",
            "examples": [
              "report.pdf",
              "image.png"
            ],
            "description": "Filename to be displayed in Slack."
          },
          "filetype": {
            "type": "string",
            "title": "Filetype",
            "examples": [
              "text",
              "pdf",
              "auto",
              "python"
            ],
            "description": "Slack file type (e.g., 'text', 'pdf'); Slack auto-detects if omitted. Refer to Slack API for full list."
          },
          "thread_ts": {
            "type": "integer",
            "title": "Thread Ts",
            "examples": [
              1678886400
            ],
            "description": "Timestamp of a parent message to upload this file as a reply; use the original message's `ts`."
          },
          "initial_comment": {
            "type": "string",
            "title": "Initial Comment",
            "examples": [
              "Here is the Q3 financial report.",
              "Check out this design mockup."
            ],
            "description": "Optional message to introduce the file in specified `channels`."
          }
        },
        "description": "Request schema for `UploadOrCreateAFileInSlack`"
      }
    }
  ],
  "tool_count": 142,
  "prompts": [],
  "resources": [],
  "remote_endpoint": "https://server.smithery.ai/slackbot/mcp",
  "packages": [],
  "sources": [
    "smithery"
  ],
  "primary_source": "smithery",
  "is_latest": true,
  "verified": false,
  "use_count": 0,
  "has_remote": true,
  "has_tools": true,
  "tool_names": [
    "SLACKBOT_ACTIVATE_OR_MODIFY_DO_NOT_DISTURB_DURATION",
    "SLACKBOT_ADD_A_CUSTOM_EMOJI_TO_A_TEAM",
    "SLACKBOT_ADD_AN_EMOJI_ALIAS_IN_SLACK",
    "SLACKBOT_ADD_A_REMOTE_FILE_FROM_A_SERVICE",
    "SLACKBOT_ADD_A_STAR_TO_AN_ITEM",
    "SLACKBOT_ADD_CALL_PARTICIPANTS",
    "SLACKBOT_ADD_EMOJI",
    "SLACKBOT_ADD_REACTION_TO_AN_ITEM",
    "SLACKBOT_ARCHIVE_A_CONVERSATION",
    "SLACKBOT_ARCHIVE_A_PUBLIC_OR_PRIVATE_CHANNEL",
    "SLACKBOT_CHAT_POST_MESSAGE",
    "SLACKBOT_CLEAR_STATUS",
    "SLACKBOT_CLOSE_DM_OR_MULTI_PERSON_DM",
    "SLACKBOT_CREATE_A_REMINDER",
    "SLACKBOT_CREATE_A_USER_GROUP",
    "SLACKBOT_CREATE_CANVAS",
    "SLACKBOT_CREATE_CHANNEL",
    "SLACKBOT_CREATE_CHANNEL_BASED_CONVERSATION",
    "SLACKBOT_CUSTOMIZE_URL_UNFURL",
    "SLACKBOT_CUSTOMIZE_URL_UNFURLING_IN_MESSAGES",
    "SLACKBOT_DELETE_A_COMMENT_ON_A_FILE",
    "SLACKBOT_DELETE_A_FILE_BY_ID",
    "SLACKBOT_DELETE_A_PUBLIC_OR_PRIVATE_CHANNEL",
    "SLACKBOT_DELETE_A_REMINDER",
    "SLACKBOT_DELETE_A_SCHEDULED_MESSAGE_IN_A_CHAT",
    "SLACKBOT_DELETE_CANVAS",
    "SLACKBOT_DELETES_A_MESSAGE_FROM_A_CHAT",
    "SLACKBOT_DELETE_USER_PROFILE_PHOTO",
    "SLACKBOT_DISABLE_AN_EXISTING_USER_GROUP",
    "SLACKBOT_EDIT_CANVAS",
    "SLACKBOT_ENABLE_A_SPECIFIED_USER_GROUP",
    "SLACKBOT_ENABLE_PUBLIC_SHARING_OF_A_FILE",
    "SLACKBOT_END_A_CALL_WITH_DURATION_AND_ID",
    "SLACKBOT_END_SNOOZE",
    "SLACKBOT_END_USER_DO_NOT_DISTURB_SESSION",
    "SLACKBOT_END_USER_SNOOZE_MODE_IMMEDIATELY",
    "SLACKBOT_FETCH_BOT_USER_INFORMATION",
    "SLACKBOT_FETCH_CONVERSATION_HISTORY",
    "SLACKBOT_FETCH_CURRENT_TEAM_INFO_WITH_OPTIONAL_TEAM_SCOPE",
    "SLACKBOT_FETCH_DND_STATUS_FOR_MULTIPLE_TEAM_MEMBERS",
    "SLACKBOT_FETCH_ITEM_REACTIONS",
    "SLACKBOT_FETCH_MESSAGE_THREAD_FROM_A_CONVERSATION",
    "SLACKBOT_FETCH_TEAM_INFO",
    "SLACKBOT_FETCH_WORKSPACE_SETTINGS_INFORMATION",
    "SLACKBOT_FIND_CHANNELS",
    "SLACKBOT_FIND_USER_BY_EMAIL_ADDRESS",
    "SLACKBOT_FIND_USERS",
    "SLACKBOT_GET_CANVAS",
    "SLACKBOT_GET_CHANNEL_CONVERSATION_PREFERENCES",
    "SLACKBOT_GET_REMINDER_INFORMATION",
    "SLACKBOT_GET_REMOTE_FILE",
    "SLACKBOT_GET_TEAM_DND_STATUS",
    "SLACKBOT_GET_USER_PRESENCE_INFO",
    "SLACKBOT_INITIATES_CHANNEL_BASED_CONVERSATIONS",
    "SLACKBOT_INVITE_USERS_TO_A_CHANNEL",
    "SLACKBOT_INVITE_USER_TO_CHANNEL",
    "SLACKBOT_INVITE_USER_TO_WORKSPACE",
    "SLACKBOT_INVITE_USER_TO_WORKSPACE_WITH_OPTIONAL_CHANNEL_INVITES",
    "SLACKBOT_JOIN_AN_EXISTING_CONVERSATION",
    "SLACKBOT_LEAVE_A_CONVERSATION",
    "SLACKBOT_LIST_ACCESSIBLE_CONVERSATIONS_FOR_A_USER",
    "SLACKBOT_LIST_ALL_CHANNELS",
    "SLACKBOT_LIST_ALL_TEAM_CHANNELS_WITH_VARIOUS_FILTERS",
    "SLACKBOT_LIST_ALL_TEAM_USERS_WITH_PAGINATION",
    "SLACKBOT_LIST_ALL_USERS",
    "SLACKBOT_LIST_ALL_USERS_IN_A_USER_GROUP",
    "SLACKBOT_LIST_CANVASES",
    "SLACKBOT_LIST_CONVERSATIONS",
    "SLACKBOT_LIST_FILES_WITH_FILTERS_IN_SLACK",
    "SLACKBOT_LIST_REMINDERS",
    "SLACKBOT_LIST_REMOTE_FILES",
    "SLACKBOT_LIST_SCHEDULED_MESSAGES",
    "SLACKBOT_LIST_SCHEDULED_MESSAGES_IN_A_CHANNEL",
    "SLACKBOT_LISTS_PINNED_ITEMS_IN_A_CHANNEL",
    "SLACKBOT_LIST_S_REMOTE_FILES_WITH_FILTERS",
    "SLACKBOT_LIST_STARRED_ITEMS",
    "SLACKBOT_LISTS_USER_S_STARRED_ITEMS_WITH_PAGINATION",
    "SLACKBOT_LIST_TEAM_CUSTOM_EMOJIS",
    "SLACKBOT_LIST_USER_GROUPS_FOR_TEAM_WITH_OPTIONS",
    "SLACKBOT_LIST_USER_REACTIONS",
    "SLACKBOT_LIST_USER_REMINDERS_WITH_DETAILS",
    "SLACKBOT_LIST_WORKSPACE_USERS",
    "SLACKBOT_LOOKUP_CANVAS_SECTIONS",
    "SLACKBOT_MANUALLY_SET_USER_PRESENCE",
    "SLACKBOT_MARK_REMINDER_AS_COMPLETE",
    "SLACKBOT_OPEN_DM",
    "SLACKBOT_OPEN_OR_RESUME_DIRECT_OR_MULTI_PERSON_MESSAGES",
    "SLACKBOT_PINS_AN_ITEM_TO_A_CHANNEL",
    "SLACKBOT_REGISTER_CALL_PARTICIPANTS_REMOVAL",
    "SLACKBOT_REGISTERS_A_NEW_CALL_WITH_PARTICIPANTS",
    "SLACKBOT_REGISTERS_NEW_CALL_PARTICIPANTS",
    "SLACKBOT_REMOVE_A_REMOTE_FILE",
    "SLACKBOT_REMOVE_A_STAR_FROM_AN_ITEM",
    "SLACKBOT_REMOVE_A_USER_FROM_A_CONVERSATION",
    "SLACKBOT_REMOVE_CALL_PARTICIPANTS",
    "SLACKBOT_REMOVE_REACTION_FROM_ITEM",
    "SLACKBOT_RENAME_A_CHANNEL",
    "SLACKBOT_RENAME_A_CONVERSATION",
    "SLACKBOT_RENAME_AN_EMOJI",
    "SLACKBOT_RETRIEVE_A_USER_S_IDENTITY_DETAILS",
    "SLACKBOT_RETRIEVE_CALL_INFORMATION",
    "SLACKBOT_RETRIEVE_CONVERSATION_INFORMATION",
    "SLACKBOT_RETRIEVE_CONVERSATION_MEMBERS_LIST",
    "SLACKBOT_RETRIEVE_CURRENT_USER_DND_STATUS",
    "SLACKBOT_RETRIEVE_DETAILED_INFORMATION_ABOUT_A_FILE",
    "SLACKBOT_RETRIEVE_DETAILED_USER_INFORMATION",
    "SLACKBOT_RETRIEVE_MESSAGE_PERMALINK_URL",
    "SLACKBOT_RETRIEVE_REMOTE_FILE_INFO_IN_SLACK",
    "SLACKBOT_RETRIEVE_TEAM_PROFILE_DETAILS",
    "SLACKBOT_RETRIEVE_USER_PROFILE_INFORMATION",
    "SLACKBOT_REVERSE_A_CONVERSATION_S_ARCHIVAL_STATUS",
    "SLACKBOT_REVOKE_PUBLIC_SHARING_ACCESS_FOR_A_FILE",
    "SLACKBOT_SCHEDULE_MESSAGE",
    "SLACKBOT_SCHEDULES_A_MESSAGE_TO_A_CHANNEL_AT_A_SPECIFIED_TIME",
    "SLACKBOT_SEARCH_ALL",
    "SLACKBOT_SEARCH_FOR_MESSAGES_WITH_QUERY",
    "SLACKBOT_SEARCH_MESSAGES",
    "SLACKBOT_SEND_EPHEMERAL_MESSAGE",
    "SLACKBOT_SEND_MESSAGE",
    "SLACKBOT_SENDS_A_MESSAGE_TO_A_CHANNEL",
    "SLACKBOT_SENDS_EPHEMERAL_MESSAGES_TO_CHANNEL_USERS",
    "SLACKBOT_SET_A_CONVERSATION_S_PURPOSE",
    "SLACKBOT_SET_DND_DURATION",
    "SLACKBOT_SET_PROFILE_PHOTO",
    "SLACKBOT_SET_READ_CURSOR_IN_A_CONVERSATION",
    "SLACKBOT_SET_STATUS",
    "SLACKBOT_SET_THE_TOPIC_OF_A_CONVERSATION",
    "SLACKBOT_SET_USER_PROFILE_INFORMATION",
    "SLACKBOT_SET_USER_PROFILE_PHOTO_WITH_CROPPING_OPTIONS",
    "SLACKBOT_SHARE_A_ME_MESSAGE_IN_A_CHANNEL",
    "SLACKBOT_SHARE_REMOTE_FILE_IN_CHANNELS",
    "SLACKBOT_START_CALL",
    "SLACKBOT_START_REAL_TIME_MESSAGING_SESSION",
    "SLACKBOT_UNARCHIVE_A_PUBLIC_OR_PRIVATE_CHANNEL",
    "SLACKBOT_UNARCHIVE_CHANNEL",
    "SLACKBOT_UNPIN_ITEM_FROM_CHANNEL",
    "SLACKBOT_UPDATE_AN_EXISTING_USER_GROUP",
    "SLACKBOT_UPDATE_CALL_INFORMATION",
    "SLACKBOT_UPDATES_A_MESSAGE",
    "SLACKBOT_UPDATES_AN_EXISTING_REMOTE_FILE",
    "SLACKBOT_UPDATE_USER_GROUP_MEMBERS",
    "SLACKBOT_UPLOAD_OR_CREATE_A_FILE_IN_SLACK"
  ]
}