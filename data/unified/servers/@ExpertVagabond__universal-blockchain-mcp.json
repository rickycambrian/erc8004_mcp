{
  "id": "@ExpertVagabond/universal-blockchain-mcp",
  "name": "@ExpertVagabond/universal-blockchain-mcp",
  "display_name": "Universal Blockchain",
  "version": null,
  "description": "Build cross-chain apps on ZetaChain, manage accounts and balances, list tokens, and request testnet ZETA. Create projects, call contracts, and transfer tokens across connected chains from one place. Track cross-chain transactions and fees with real-time queries and network status.",
  "icon_url": "https://icons.duckduckgo.com/ip3/zetachain.com.ico",
  "repository_url": null,
  "status": "active",
  "published_at": null,
  "tools": [
    {
      "name": "create_account",
      "description": "Create a new ZetaChain account with mnemonic phrase",
      "inputSchema": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Account name identifier"
          }
        }
      }
    },
    {
      "name": "import_account",
      "description": "Import existing account using private key or mnemonic",
      "inputSchema": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Account name identifier"
          },
          "mnemonic": {
            "type": "string",
            "description": "Mnemonic phrase to import (optional if private key provided)"
          },
          "privateKey": {
            "type": "string",
            "description": "Private key to import (optional if mnemonic provided)"
          }
        }
      }
    },
    {
      "name": "list_accounts",
      "description": "List all available ZetaChain accounts",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "show_account",
      "description": "Show details of a specific account",
      "inputSchema": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Account name to show details for"
          }
        }
      }
    },
    {
      "name": "get_balances",
      "description": "Fetch native and ZETA token balances for an address",
      "inputSchema": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain to query (optional)"
          },
          "address": {
            "type": "string",
            "description": "Address to check balances for"
          }
        }
      }
    },
    {
      "name": "query_cctx",
      "description": "Query cross-chain transaction data in real-time",
      "inputSchema": {
        "type": "object",
        "required": [
          "hash"
        ],
        "properties": {
          "hash": {
            "type": "string",
            "description": "Cross-chain transaction hash"
          }
        }
      }
    },
    {
      "name": "get_fees",
      "description": "Fetch omnichain and cross-chain messaging fees",
      "inputSchema": {
        "type": "object",
        "properties": {
          "to": {
            "type": "string",
            "description": "Destination chain"
          },
          "from": {
            "type": "string",
            "description": "Source chain"
          }
        }
      }
    },
    {
      "name": "call_contract",
      "description": "Call a contract on a connected chain from ZetaChain",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract",
          "chain"
        ],
        "properties": {
          "data": {
            "type": "string",
            "description": "Contract call data"
          },
          "chain": {
            "type": "string",
            "description": "Target chain"
          },
          "amount": {
            "type": "string",
            "description": "Amount to send"
          },
          "contract": {
            "type": "string",
            "description": "Contract address to call"
          }
        }
      }
    },
    {
      "name": "withdraw_tokens",
      "description": "Withdraw tokens from ZetaChain to a connected chain",
      "inputSchema": {
        "type": "object",
        "required": [
          "amount",
          "chain",
          "recipient"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Destination chain"
          },
          "token": {
            "type": "string",
            "description": "Token address (optional for native)"
          },
          "amount": {
            "type": "string",
            "description": "Amount to withdraw"
          },
          "recipient": {
            "type": "string",
            "description": "Recipient address"
          }
        }
      }
    },
    {
      "name": "withdraw_and_call",
      "description": "Withdraw tokens from ZetaChain and call a contract on connected chain",
      "inputSchema": {
        "type": "object",
        "required": [
          "amount",
          "chain",
          "contract"
        ],
        "properties": {
          "data": {
            "type": "string",
            "description": "Contract call data"
          },
          "chain": {
            "type": "string",
            "description": "Destination chain"
          },
          "amount": {
            "type": "string",
            "description": "Amount to withdraw"
          },
          "contract": {
            "type": "string",
            "description": "Contract to call"
          }
        }
      }
    },
    {
      "name": "list_tokens",
      "description": "List ZRC-20 tokens",
      "inputSchema": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain to filter tokens by"
          }
        }
      }
    },
    {
      "name": "list_chains",
      "description": "List all supported chains",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "request_faucet",
      "description": "Request testnet ZETA tokens from the faucet",
      "inputSchema": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "type": "string",
            "description": "Address to send faucet tokens to"
          }
        }
      }
    },
    {
      "name": "create_project",
      "description": "Create a new universal contract project",
      "inputSchema": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Project name"
          },
          "template": {
            "type": "string",
            "description": "Project template (hello, swap, etc.)"
          }
        }
      }
    },
    {
      "name": "get_network_info",
      "description": "Get current ZetaChain network status and information",
      "inputSchema": {
        "type": "object",
        "properties": {
          "network": {
            "enum": [
              "mainnet",
              "testnet"
            ],
            "type": "string",
            "default": "testnet",
            "description": "Network to query (mainnet or testnet)"
          }
        }
      }
    },
    {
      "name": "check_foundry",
      "description": "Check if Foundry (forge, cast, anvil) is properly installed and working",
      "inputSchema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "forge_build",
      "description": "Compile smart contracts using Foundry Forge",
      "inputSchema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Project path (optional)"
          }
        }
      }
    },
    {
      "name": "forge_test",
      "description": "Run smart contract tests using Foundry Forge",
      "inputSchema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Project path (optional)"
          },
          "pattern": {
            "type": "string",
            "description": "Test pattern to match (optional)"
          }
        }
      }
    },
    {
      "name": "forge_create",
      "description": "Deploy smart contracts using Foundry Forge",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract",
          "rpc_url",
          "private_key"
        ],
        "properties": {
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          },
          "contract": {
            "type": "string",
            "description": "Contract path/name"
          },
          "private_key": {
            "type": "string",
            "description": "Private key for deployment"
          },
          "constructor_args": {
            "type": "string",
            "description": "Constructor arguments (optional)"
          }
        }
      }
    },
    {
      "name": "forge_verify",
      "description": "Verify smart contracts on block explorers",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "contract_name",
          "api_key",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain name (mainnet, sepolia, etc.)"
          },
          "api_key": {
            "type": "string",
            "description": "Block explorer API key"
          },
          "contract_name": {
            "type": "string",
            "description": "Contract name"
          },
          "contract_address": {
            "type": "string",
            "description": "Deployed contract address"
          }
        }
      }
    },
    {
      "name": "cast_call",
      "description": "Make a read-only call to a smart contract",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "function_signature",
          "rpc_url"
        ],
        "properties": {
          "args": {
            "type": "string",
            "description": "Function arguments (optional)"
          },
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          },
          "contract_address": {
            "type": "string",
            "description": "Contract address"
          },
          "function_signature": {
            "type": "string",
            "description": "Function signature"
          }
        }
      }
    },
    {
      "name": "cast_send",
      "description": "Send a transaction to a smart contract",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "function_signature",
          "rpc_url",
          "private_key"
        ],
        "properties": {
          "args": {
            "type": "string",
            "description": "Function arguments (optional)"
          },
          "value": {
            "type": "string",
            "description": "ETH value to send (optional)"
          },
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          },
          "private_key": {
            "type": "string",
            "description": "Private key for signing"
          },
          "contract_address": {
            "type": "string",
            "description": "Contract address"
          },
          "function_signature": {
            "type": "string",
            "description": "Function signature"
          }
        }
      }
    },
    {
      "name": "cast_balance",
      "description": "Get ETH balance of an address",
      "inputSchema": {
        "type": "object",
        "required": [
          "address",
          "rpc_url"
        ],
        "properties": {
          "address": {
            "type": "string",
            "description": "Address to check"
          },
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          }
        }
      }
    },
    {
      "name": "cast_nonce",
      "description": "Get transaction nonce for an address",
      "inputSchema": {
        "type": "object",
        "required": [
          "address",
          "rpc_url"
        ],
        "properties": {
          "address": {
            "type": "string",
            "description": "Address to check"
          },
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          }
        }
      }
    },
    {
      "name": "cast_gas_price",
      "description": "Get current gas price",
      "inputSchema": {
        "type": "object",
        "required": [
          "rpc_url"
        ],
        "properties": {
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          }
        }
      }
    },
    {
      "name": "cast_block",
      "description": "Get block information",
      "inputSchema": {
        "type": "object",
        "required": [
          "block",
          "rpc_url"
        ],
        "properties": {
          "block": {
            "type": "string",
            "description": "Block number or hash"
          },
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          }
        }
      }
    },
    {
      "name": "cast_tx",
      "description": "Get transaction information",
      "inputSchema": {
        "type": "object",
        "required": [
          "tx_hash",
          "rpc_url"
        ],
        "properties": {
          "rpc_url": {
            "type": "string",
            "description": "RPC URL"
          },
          "tx_hash": {
            "type": "string",
            "description": "Transaction hash"
          }
        }
      }
    },
    {
      "name": "anvil_start",
      "description": "Start a local Ethereum node using Anvil",
      "inputSchema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "number",
            "description": "Port to run on (default: 8545)"
          },
          "balance": {
            "type": "number",
            "description": "Balance per account in ETH (default: 10000)"
          },
          "accounts": {
            "type": "number",
            "description": "Number of test accounts (default: 10)"
          },
          "fork_url": {
            "type": "string",
            "description": "URL to fork from (optional)"
          }
        }
      }
    },
    {
      "name": "anvil_snapshot",
      "description": "Create a snapshot of the current blockchain state",
      "inputSchema": {
        "type": "object",
        "properties": {
          "rpc_url": {
            "type": "string",
            "description": "Anvil RPC URL (default: http://localhost:8545)"
          }
        }
      }
    },
    {
      "name": "anvil_revert",
      "description": "Revert to a previous snapshot",
      "inputSchema": {
        "type": "object",
        "required": [
          "snapshot_id"
        ],
        "properties": {
          "rpc_url": {
            "type": "string",
            "description": "Anvil RPC URL (default: http://localhost:8545)"
          },
          "snapshot_id": {
            "type": "string",
            "description": "Snapshot ID to revert to"
          }
        }
      }
    },
    {
      "name": "zeta_validator_create",
      "description": "Create a ZetaChain validator",
      "inputSchema": {
        "type": "object",
        "required": [
          "moniker",
          "amount"
        ],
        "properties": {
          "amount": {
            "type": "string",
            "description": "Stake amount"
          },
          "moniker": {
            "type": "string",
            "description": "Validator name"
          },
          "commission_rate": {
            "type": "string",
            "description": "Commission rate"
          },
          "min_self_delegation": {
            "type": "string",
            "description": "Minimum self-delegation"
          }
        }
      }
    },
    {
      "name": "zeta_governance_vote",
      "description": "Vote on ZetaChain governance proposals",
      "inputSchema": {
        "type": "object",
        "required": [
          "proposal_id",
          "vote",
          "from_account"
        ],
        "properties": {
          "vote": {
            "enum": [
              "yes",
              "no",
              "abstain",
              "no_with_veto"
            ],
            "type": "string",
            "description": "Vote option"
          },
          "proposal_id": {
            "type": "string",
            "description": "Proposal ID"
          },
          "from_account": {
            "type": "string",
            "description": "Account to vote from"
          }
        }
      }
    },
    {
      "name": "zeta_governance_proposals",
      "description": "List active governance proposals",
      "inputSchema": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "description": "Proposal status filter (optional)"
          }
        }
      }
    },
    {
      "name": "zeta_staking_delegate",
      "description": "Delegate ZETA tokens to a validator",
      "inputSchema": {
        "type": "object",
        "required": [
          "validator_address",
          "amount",
          "from_account"
        ],
        "properties": {
          "amount": {
            "type": "string",
            "description": "Amount to delegate"
          },
          "from_account": {
            "type": "string",
            "description": "Account to delegate from"
          },
          "validator_address": {
            "type": "string",
            "description": "Validator address"
          }
        }
      }
    },
    {
      "name": "zeta_staking_rewards",
      "description": "Query staking rewards for a delegator",
      "inputSchema": {
        "type": "object",
        "required": [
          "delegator_address"
        ],
        "properties": {
          "delegator_address": {
            "type": "string",
            "description": "Delegator address"
          },
          "validator_address": {
            "type": "string",
            "description": "Validator address (optional)"
          }
        }
      }
    },
    {
      "name": "cross_chain_send",
      "description": "Send tokens across chains using ZetaChain",
      "inputSchema": {
        "type": "object",
        "required": [
          "from_chain",
          "to_chain",
          "token",
          "amount",
          "recipient",
          "from_account"
        ],
        "properties": {
          "token": {
            "type": "string",
            "description": "Token to send"
          },
          "amount": {
            "type": "string",
            "description": "Amount to send"
          },
          "to_chain": {
            "type": "string",
            "description": "Destination chain"
          },
          "recipient": {
            "type": "string",
            "description": "Recipient address"
          },
          "from_chain": {
            "type": "string",
            "description": "Source chain"
          },
          "from_account": {
            "type": "string",
            "description": "Sender account"
          }
        }
      }
    },
    {
      "name": "cross_chain_status",
      "description": "Check status of cross-chain transaction",
      "inputSchema": {
        "type": "object",
        "properties": {
          "tx_hash": {
            "type": "string",
            "description": "Transaction hash"
          },
          "cctx_index": {
            "type": "string",
            "description": "CCTX index (optional)"
          }
        }
      }
    },
    {
      "name": "contract_compile",
      "description": "Compile Solidity smart contracts",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_path"
        ],
        "properties": {
          "optimize": {
            "type": "boolean",
            "description": "Enable optimization (default: true)"
          },
          "output_dir": {
            "type": "string",
            "description": "Output directory (optional)"
          },
          "contract_path": {
            "type": "string",
            "description": "Path to contract file"
          }
        }
      }
    },
    {
      "name": "contract_deploy",
      "description": "Deploy compiled smart contracts",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_name",
          "chain",
          "from_account"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Target chain"
          },
          "from_account": {
            "type": "string",
            "description": "Deployer account"
          },
          "contract_name": {
            "type": "string",
            "description": "Contract name"
          },
          "constructor_args": {
            "type": "array",
            "description": "Constructor arguments"
          }
        }
      }
    },
    {
      "name": "contract_interact",
      "description": "Interact with deployed smart contracts",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "function_name",
          "chain"
        ],
        "properties": {
          "args": {
            "type": "array",
            "description": "Function arguments"
          },
          "chain": {
            "type": "string",
            "description": "Chain where contract is deployed"
          },
          "from_account": {
            "type": "string",
            "description": "Account to use for interaction"
          },
          "function_name": {
            "type": "string",
            "description": "Function to call"
          },
          "contract_address": {
            "type": "string",
            "description": "Contract address"
          }
        }
      }
    },
    {
      "name": "defi_swap",
      "description": "Perform token swaps on DEX platforms",
      "inputSchema": {
        "type": "object",
        "required": [
          "from_token",
          "to_token",
          "amount",
          "chain"
        ],
        "properties": {
          "dex": {
            "type": "string",
            "description": "DEX platform (uniswap, pancakeswap, etc.)"
          },
          "chain": {
            "type": "string",
            "description": "Chain to swap on"
          },
          "amount": {
            "type": "string",
            "description": "Amount to swap"
          },
          "slippage": {
            "type": "number",
            "description": "Slippage tolerance (optional)"
          },
          "to_token": {
            "type": "string",
            "description": "Token to swap to"
          },
          "from_token": {
            "type": "string",
            "description": "Token to swap from"
          }
        }
      }
    },
    {
      "name": "defi_liquidity_add",
      "description": "Add liquidity to DEX pools",
      "inputSchema": {
        "type": "object",
        "required": [
          "token_a",
          "token_b",
          "amount_a",
          "amount_b",
          "chain"
        ],
        "properties": {
          "dex": {
            "type": "string",
            "description": "DEX platform"
          },
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "token_a": {
            "type": "string",
            "description": "First token"
          },
          "token_b": {
            "type": "string",
            "description": "Second token"
          },
          "amount_a": {
            "type": "string",
            "description": "Amount of token A"
          },
          "amount_b": {
            "type": "string",
            "description": "Amount of token B"
          }
        }
      }
    },
    {
      "name": "defi_yield_farm",
      "description": "Stake tokens in yield farming protocols",
      "inputSchema": {
        "type": "object",
        "required": [
          "protocol",
          "pool",
          "amount",
          "chain"
        ],
        "properties": {
          "pool": {
            "type": "string",
            "description": "Pool/farm identifier"
          },
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "amount": {
            "type": "string",
            "description": "Amount to stake"
          },
          "protocol": {
            "type": "string",
            "description": "DeFi protocol name"
          }
        }
      }
    },
    {
      "name": "nft_mint",
      "description": "Mint NFTs",
      "inputSchema": {
        "type": "object",
        "required": [
          "collection",
          "recipient",
          "metadata_uri",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "recipient": {
            "type": "string",
            "description": "Recipient address"
          },
          "collection": {
            "type": "string",
            "description": "NFT collection address"
          },
          "metadata_uri": {
            "type": "string",
            "description": "Metadata URI"
          }
        }
      }
    },
    {
      "name": "nft_transfer",
      "description": "Transfer NFTs",
      "inputSchema": {
        "type": "object",
        "required": [
          "collection",
          "token_id",
          "from_address",
          "to_address",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "token_id": {
            "type": "string",
            "description": "Token ID"
          },
          "collection": {
            "type": "string",
            "description": "NFT collection address"
          },
          "to_address": {
            "type": "string",
            "description": "New owner"
          },
          "from_address": {
            "type": "string",
            "description": "Current owner"
          }
        }
      }
    },
    {
      "name": "nft_metadata",
      "description": "Get NFT metadata",
      "inputSchema": {
        "type": "object",
        "required": [
          "collection",
          "token_id",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "token_id": {
            "type": "string",
            "description": "Token ID"
          },
          "collection": {
            "type": "string",
            "description": "NFT collection address"
          }
        }
      }
    },
    {
      "name": "block_explorer",
      "description": "Search and analyze blockchain data",
      "inputSchema": {
        "type": "object",
        "required": [
          "query",
          "chain"
        ],
        "properties": {
          "type": {
            "type": "string",
            "description": "Query type (address, transaction, block)"
          },
          "chain": {
            "type": "string",
            "description": "Chain to search on"
          },
          "query": {
            "type": "string",
            "description": "Search query (address, tx hash, block)"
          }
        }
      }
    },
    {
      "name": "gas_tracker",
      "description": "Track and analyze gas prices across chains",
      "inputSchema": {
        "type": "object",
        "properties": {
          "chains": {
            "type": "array",
            "description": "List of chains to check"
          },
          "period": {
            "type": "string",
            "description": "Time period (1h, 24h, 7d)"
          }
        }
      }
    },
    {
      "name": "portfolio_tracker",
      "description": "Track portfolio value across multiple chains",
      "inputSchema": {
        "type": "object",
        "required": [
          "addresses"
        ],
        "properties": {
          "chains": {
            "type": "array",
            "description": "Chains to include"
          },
          "addresses": {
            "type": "array",
            "description": "List of addresses to track"
          }
        }
      }
    },
    {
      "name": "security_audit",
      "description": "Perform basic security audit on smart contracts",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "analysis_type": {
            "enum": [
              "basic",
              "detailed"
            ],
            "type": "string",
            "description": "Type of analysis"
          },
          "contract_address": {
            "type": "string",
            "description": "Contract address"
          }
        }
      }
    },
    {
      "name": "wallet_export",
      "description": "Export wallet private key or mnemonic",
      "inputSchema": {
        "type": "object",
        "required": [
          "account_name",
          "format"
        ],
        "properties": {
          "format": {
            "enum": [
              "private_key",
              "mnemonic",
              "keystore"
            ],
            "type": "string",
            "description": "Export format"
          },
          "account_name": {
            "type": "string",
            "description": "Account name to export"
          }
        }
      }
    },
    {
      "name": "wallet_backup",
      "description": "Create encrypted backup of wallet",
      "inputSchema": {
        "type": "object",
        "required": [
          "account_name",
          "password"
        ],
        "properties": {
          "password": {
            "type": "string",
            "description": "Encryption password"
          },
          "account_name": {
            "type": "string",
            "description": "Account name to backup"
          }
        }
      }
    },
    {
      "name": "transaction_history",
      "description": "Get transaction history for an address",
      "inputSchema": {
        "type": "object",
        "required": [
          "address",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain to query"
          },
          "limit": {
            "type": "number",
            "description": "Number of transactions to return (default: 50)"
          },
          "address": {
            "type": "string",
            "description": "Address to query"
          }
        }
      }
    },
    {
      "name": "gas_optimizer",
      "description": "Optimize gas usage for smart contract transactions",
      "inputSchema": {
        "type": "object",
        "required": [
          "contract_address",
          "function_call",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain"
          },
          "function_call": {
            "type": "string",
            "description": "Function call to optimize"
          },
          "contract_address": {
            "type": "string",
            "description": "Contract address"
          }
        }
      }
    },
    {
      "name": "multisig_create",
      "description": "Create a multisig wallet",
      "inputSchema": {
        "type": "object",
        "required": [
          "owners",
          "threshold",
          "chain"
        ],
        "properties": {
          "chain": {
            "type": "string",
            "description": "Chain to deploy on"
          },
          "owners": {
            "type": "array",
            "description": "List of owner addresses"
          },
          "threshold": {
            "type": "number",
            "description": "Number of signatures required"
          }
        }
      }
    },
    {
      "name": "bridge_status",
      "description": "Check status of cross-chain bridge operations",
      "inputSchema": {
        "type": "object",
        "required": [
          "tx_hash"
        ],
        "properties": {
          "tx_hash": {
            "type": "string",
            "description": "Transaction hash"
          },
          "bridge_type": {
            "type": "string",
            "description": "Bridge type (zeta, layerzero, etc.)"
          }
        }
      }
    }
  ],
  "tool_count": 56,
  "prompts": [],
  "resources": [],
  "remote_endpoint": "https://server.smithery.ai/@ExpertVagabond/universal-blockchain-mcp/mcp",
  "packages": [],
  "sources": [
    "smithery"
  ],
  "primary_source": "smithery",
  "is_latest": true,
  "verified": false,
  "use_count": 0,
  "has_remote": true,
  "has_tools": true,
  "tool_names": [
    "create_account",
    "import_account",
    "list_accounts",
    "show_account",
    "get_balances",
    "query_cctx",
    "get_fees",
    "call_contract",
    "withdraw_tokens",
    "withdraw_and_call",
    "list_tokens",
    "list_chains",
    "request_faucet",
    "create_project",
    "get_network_info",
    "check_foundry",
    "forge_build",
    "forge_test",
    "forge_create",
    "forge_verify",
    "cast_call",
    "cast_send",
    "cast_balance",
    "cast_nonce",
    "cast_gas_price",
    "cast_block",
    "cast_tx",
    "anvil_start",
    "anvil_snapshot",
    "anvil_revert",
    "zeta_validator_create",
    "zeta_governance_vote",
    "zeta_governance_proposals",
    "zeta_staking_delegate",
    "zeta_staking_rewards",
    "cross_chain_send",
    "cross_chain_status",
    "contract_compile",
    "contract_deploy",
    "contract_interact",
    "defi_swap",
    "defi_liquidity_add",
    "defi_yield_farm",
    "nft_mint",
    "nft_transfer",
    "nft_metadata",
    "block_explorer",
    "gas_tracker",
    "portfolio_tracker",
    "security_audit",
    "wallet_export",
    "wallet_backup",
    "transaction_history",
    "gas_optimizer",
    "multisig_create",
    "bridge_status"
  ]
}